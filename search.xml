<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端性能优化--updating]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F2017%2F03%2F02%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-updating.html</url>
    <content type="text"><![CDATA[优化方向 优化手段 请求数量 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽 开启GZip，精简JavaScript，移除重复脚本，图像优化 缓存利用 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验 避免CSS表达式，避免重定向 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/前端工程/2017/03/02/前端性能优化-updating.html]]></content>
      <categories>
        <category>前端工程</category>
      </categories>
      <tags>
        <tag>前端工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程需要用到的技术元素]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F2017%2F03%2F02%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF%E5%85%83%E7%B4%A0.html</url>
    <content type="text"><![CDATA[对于好的文章收录是我长期以来的爱好，这里感谢云龙大牛的分享 前端行业经历了这么长时间的发展，技术元素非常丰富，这里列举出一般web团队需要用到的技术元素： 开发规范：包括开发、部署的目录规范，编码规范等。不要小瞧规范的威力，可以极大的提升开发效率，真正优秀的规范不会让使用者感到约束，而是能帮助他们快速定位问题，提升效率。 2.模块化开发：针对js、css，以功能或业务为单元组织代码。js方面解决独立作用域、依赖管理、api暴露、按需加载与执行、安全合并等问题，css方面解决依赖管理、组件内部样式管理等问题。是提升前端开发效率的重要基础。现在流行的模块化框架有requirejs、seajs等。 3.组件化开发：在模块化基础上，以页面小部件(component)为单位将页面小部件的js、css、html代码片段放在一起进行开发、维护，组件单元是资源独立的，组件在系统内可复用。比如头部(header)、尾部(footer)、搜索框(searchbar)、导航(menu)、对话框(dialog)等，甚至一些复杂的组件比如编辑器(editor)等。通常业务会针对组件化的js部分进行必要的封装，解决一些常见的组件渲染、交互问题。 4.组件仓库：有了组件化，我们希望将一些非常通用的组件放到一个公共的地方供团队共享，方便新项目复用，这个时候我们就需要引入一个组件仓库的东西，现在流行的组件库有bower、component等。团队发展到一定规模后，组件库的需求会变得非常强烈。 5.性能优化：这里的性能优化是指能够通过工程手段保证的性能优化点。由于其内容比较丰富，就不在这里展开了，感兴趣的同学可以阅读我的这两篇文章 [1] [2]。性能优化是前端项目发展到一定阶段必须经历的过程。这部分我想强调的一点是 性能优化一定是一个工程问题和统计问题，不能用工程手段保证的性能优化是不靠谱的，优化时只考虑一个页面的首次加载，不考虑全局在宏观统计上的优化提升也是片面的。 6.项目部署：部署按照现行业界的分工标准，虽然不是前端的工作范畴，但它对性能优化有直接的影响，包括静态资源缓存、cdn、非覆盖式发布等问题。合理的静态资源资源部署可以为前端性能带来较大的优化空间。 7.开发流程：完整的开发流程包括本地开发调试、视觉效果走查确认、前后端联调、提测、上线等环节。对开发流程的改善可以大幅降低开发的时间成本，工作这些年见过很多独立的系统（cms系统、静态资源推送系统）将开发流程割裂开，对前端开发的效率有严重的阻碍。 8.开发工具：这里说的工具不是指IDE，而是工程工具，包括构建与优化工具、开发-调试-部署等流程工具，以及组件库获取、提交等相关工具，甚至运营、文档、配置发布等平台工具。前端开发需要工具支持，这个问题的根本原因来自前端领域语言特性（未来我会单独写一篇文章介绍前端领域语言缺陷问题）。前端开发所使用的语言（js、css、html）以及前端工程资源的加载与定位策略决定了前端工程必须要工具支持。由于这些工具通常都是独立的系统，要想把它们串联起来，才有了yeoman这样的封装。前面提到的7项技术元素都直接或间接的对前端开发工具设计产生一定的影响，因此能否串联其他技术要素，使得前端开发形成一个连贯可持续优化的开发体系，工具的设计至关重要。 以上8项，1-3是技术和业务相关的开发需求，4是技术沉淀与共享需求，5-8是工程优化需求。 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/前端工程/2017/03/02/前端工程需要用到的技术元素.html]]></content>
      <categories>
        <category>前端工程</category>
      </categories>
      <tags>
        <tag>前端工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解 SeaJS 与 RequireJS 的差异]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2F2017%2F03%2F02%2F%E7%90%86%E8%A7%A3seaSs%E5%92%8CrequireJs%E7%9A%84%E5%B7%AE%E5%BC%82.html</url>
    <content type="text"><![CDATA[requirejs和seajs二者在加载上都有缺陷，就是模块的依赖要等到模块加载完成后，通过静态分析（seajs）或者deps参数（requirejs）来获取，这就为 合并请求 和 按需加载 带来了实现上的矛盾： 要么放弃按需加载，把所有js合成一个文件，从而满足请求合并（两个框架的官方demo都有这样的例子）；要么放弃请求合并，请求独立的模块文件，从而满足按需加载。AMD规范在执行callback的时候，要初始化所有依赖的模块，而CMD只有执行到require的时候才初始化模块. CMD 模块依赖声明方式12345define(function (require) &#123; var a = require('./a'); var b = require('./b'); // more code ..&#125;) CMD 依赖是就近声明，通过内部require方法进行声明。但是因为是异步模块，加载器需要提前加载这些模块，所以模块真正使用前需要提取模块里面所有的依赖。无论是加载器即时提取，还是通过自动化工具预先提取，CMD 的这种依赖声明格式只能通过静态分析方式实现，这也正是 CMD 的弊端所在。 CMD 规范的弊端1.不能直接压缩：require是局部变量，意味着不能直接的通过压缩工具进行压缩，若require这个变量被替换，加载器与自动化工具将无法获取模块的依赖。2.模块书写有额外约定：路径参数不能进行字符串运算，不能使用变量代替，否则加载器与自动化工具无法正确提取路径。 注：SeaJS 静态分析实现是把模块包toString()后使用正则提取require部分得到依赖的模块路径。 AMD 模块依赖声明方式123define(['./a', './b'], function (a, b) &#123; // more code ..&#125;) AMD 的依赖是提前声明。这种优势的好处就是依赖无需通过静态分析，无论是加载器还是自动化工具都可以很直接的获取到依赖，规范的定义可以更简单，意味着可能产生更强大的实现，这对加载器与自动化分析工具都是有利的。 AMD 规范的弊端1.依赖提前声明在代码书写上不是那么友好2.模块内部与 NodeJS 的 Modules 有一定的差异 关于第二点的问题需要特别说明下。其实无论是 CMD 还是 AMD 的异步模块，都无法与同步模块规范保持一致（NodeJS 的 Modules），只有谁比谁更像同步模块而已。AMD 要转换为同步模块，除了去掉define函数的包裹外，需要在头部使用require把依赖声明好，而 CMD 只需要去掉define函数的包裹即可。 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/前端模块化/2017/03/02/理解seaSs和requireJs的差异.html]]></content>
      <categories>
        <category>前端模块化</category>
      </categories>
      <tags>
        <tag>SeaJS</tag>
        <tag>RequireJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[何为web前端？前端工程分哪些阶段？]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F2017%2F03%2F02%2F%E4%BD%95%E4%B8%BAweb%E5%89%8D%E7%AB%AF%EF%BC%9F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%88%86%E5%93%AA%E4%BA%9B%E9%98%B6%E6%AE%B5%EF%BC%9F.html</url>
    <content type="text"><![CDATA[对于好的文章收录是我长期以来的爱好，这里感谢云龙大牛的分享 不知道你的团队如何定义前端开发，据我所知，时至今日仍然有很多团队会把前端开发归类为产品或者设计岗位，虽然身份之争多少有些无谓，但我对这种偏见还是心存芥蒂，酝酿了许久，决定写一个系列的文章，试着从工程的角度系统的介绍一下我对前端，尤其是Web前端的理解。 只要我们还把自己的工作看作为一项软件开发活动，那么我相信读过下面的内容你也一定会有所共鸣。 前端，是一种GUI软件 现如今前端可谓包罗万象，产品形态五花八门，涉猎极广，什么高大上的基础库/框架，拽炫酷的宣传页面，还有屌炸天的小游戏……不过这些一两个文件的小项目并非是前端技术的主要应用场景，更具商业价值的则是复杂的Web应用，它们功能完善，界面繁多，为用户提供了完整的产品体验，可能是新闻聚合网站，可能是在线购物平台，可能是社交网络，可能是金融信贷应用，可能是音乐互动社区，也可能是视频上传与分享平台…… 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。 如此复杂的Web应用，动辄几十上百人共同开发维护，其前端界面通常也颇具规模，工程量不亚于一般的传统GUI软件： 尽管Web应用的复杂程度与日俱增，用户对其前端界面也提出了更高的要求，但时至今日仍然没有多少前端开发者会从软件工程的角度去思考前端开发，来助力团队的开发效率，更有甚者还对前端保留着”如玩具般简单“的刻板印象，日复一日，刀耕火种。 历史悠久的前端开发，始终像是放养的野孩子，原始如斯，不免让人慨叹！ 前端工程的三个阶段现在的前端开发倒也并非一无所有，回顾一下曾经经历过或听闻过的项目，为了提升其前端开发效率和运行性能，前端团队的工程建设大致会经历三个阶段： 第一阶段：库/框架选型 前端工程建设的第一项任务就是根据项目特征进行技术选型。 基本上现在没有人完全从0开始做网站，哪怕是政府项目用个jquery都很正常吧，React/Angularjs等框架横空出世，解放了不少生产力，合理的技术选型可以为项目节省许多工程量这点毋庸置疑。 第二阶段：简单构建优化 选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。 前端开发工程化程度之低，常常出乎我的意料，我之前在百度工作时是没有多少概念的，直到离开大公司的温室，去到业界与更多的团队交流才发现，能做到这个阶段在业界来说已然超出平均水平，属于“具备较高工程化程度”的团队了，查看网上形形色色的网页源代码，能做到最基本的JS/CSS压缩的Web应用都已跨入标准互联网公司行列，不难理解为什么很多前端团队对于前端工程构建的认知还仅停留在“压缩、校验、合并”这种程度。 第三阶段：JS/CSS模块化开发 分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。在解决了基本开发效率运行效率问题之后，前端团队开始思考维护效率，模块化是目前前端最流行的分治手段。 很多人觉得模块化开发的工程意义是复用，我不太认可这种看法，在我看来，模块化开发的最大价值应该是分治，是分治，分治！（重说三）。 不管你将来是否要复用某段代码，你都有充分的理由将其分治为一个模块。 JS模块化方案很多，AMD/CommonJS/UMD/ES6 Module等，对应的框架和工具也一大堆，说起来很烦，大家自行百度吧；CSS模块化开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的。 虽然这些技术由来已久，在如今这个“言必及React”的时代略显落伍，但想想业界的绝大多数团队的工程化落后程度，放眼望去，毫不夸张的说，能达到第三阶段的前端团队已属于高端行列，基本具备了开发维护一般规模Web应用的能力。 然而，做到这些就够了么？Naive！ 第四阶段 前端是一种技术问题较少、工程问题较多的软件开发领域。 当我们要开发一款完整的Web应用时，前端将面临更多的工程问题，比如： 大体量：多功能、多页面、多状态、多系统； 大规模：多人甚至多团队合作开发； 高性能：CDN部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏CSS内嵌、HTTP 2.0服务端资源推送。 扩展阅读：大公司里怎样开发和部署前端代码？ 这些无疑是一系列严肃的系统工程问题。 前面讲的三个阶段虽然相比曾经“茹毛饮血”的时代进步不少，但用于支撑第四阶段的多人合作开发以及精细的性能优化似乎还欠缺点什么。 到底，缺什么呢？ 没有银弹读过《人月神话》的人应该都听说过，软件工程 没有银弹。没错，前端开发同样没有银弹，可是现在是连™铅弹都没有的年月！（刚有了BB弹，摔） 前端历来以“简单”著称，在前端开发者群体中，小而美的价值观占据着主要的话语权，甚至成为了某种信仰，想与其他人交流一下工程方面的心得，得到的回应往往都是两个字：太重。 重你妹！你的脑容量只有4K吗？ 工程方案其实也可以小而美！只不过它的小而美不是指代码量，而是指“规则”。找到问题的根源，用最少最简单明了的规则制定出最容易遵守最容易理解的开发规范或工具，以提升开发效率和工程质量，这同样是小而美的典范！ 2011年我有幸参与到 FIS 项目中，与百度众多大中型项目的前端研发团队共同合作，不断探索实践前端开发的工程化解决方案，13年离开百度去往UC，面对完全不同的产品形态，不同的业务场景，不同的适配终端，甚至不同的网络环境，过往的方法论仍然能够快速落地，为多个团队的不同业务场景量身定制出合理的前端解决方案。 这些经历让我明悟了一个道理： 进入第四阶段，我们只需做好两件事就能大幅提升前端开发效率，并且兼顾运行性能，那就是——组件化开发与资源管理。 第一件事：组件化开发分治的确是非常重要的工程优化手段。在我看来，前端作为一种GUI软件，光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求： 如上图，这是我所信仰的前端组件化开发理念，简单解读一下： 页面上的每个 独立的 可视/可交互区域视为一个组件； 每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护； 由于组件具有独立性，因此组件与组件之间可以 自由组合； 页面只不过是组件的容器，负责组合组件形成功能完整的界面； 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。 其中第二项描述的就近维护原则，是我觉得最具工程价值的地方，它为前端开发提供了很好的分治策略，每个开发者都将清楚的知道，自己所开发维护的功能单元，其代码必然存在于对应的组件目录中，在那个目录下能找到有关这个功能单元的所有内部逻辑，样式也好，JS也好，页面结构也好，都在那里。 组件化开发具有较高的通用性，无论是前端渲染的单页面应用，还是后端模板渲染的多页面应用，组件化开发的概念都能适用。组件HTML部分根据业务选型的不同，可以是静态的HTML文件，可以是前端模板，也可以是后端模板： 不同的技术选型决定了不同的组件封装和调用策略。 基于这样的工程理念，我们很容易将系统以独立的组件为单元进行分工划分： 由于系统功能被分治到独立的模块或组件中，粒度比较精细，组织形式松散，开发者之间不会产生开发时序的依赖，大幅提升并行的开发效率，理论上允许随时加入新成员认领组件开发或维护工作，也更容易支持多个团队共同维护一个大型站点的开发。 结合前面提到的模块化开发，整个前端项目可以划分为这么几种开发概念： 名称 说明 举例 JS模块 独立的算法和数据单元 浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元 CSS模块 独立的功能性样式单元 栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元 UI组件 独立的可视/可交互功能单元 页头(header)，页尾(footer)，导航栏(nav)，搜索框(search) 页面 前端这种GUI软件的界面状态，是UI组件的容器 首页(index)，列表页(list)，用户管理(user) 应用 整个项目或整个站点被称之为应用，由多个页面组成 以上5种开发概念以相对较少的规则组成了前端开发的基本工程结构，基于这些理念，我眼中的前端开发就成了这个样子： 示意图 描述 整个Web应用由页面组成 页面由组件组成 一个组件一个目录，资源就近维护 组件可组合， 组件的JS可依赖其他JS模块，CSS可依赖其他CSS单元 | 综合上面的描述，对于一般中小规模的项目，大致可以规划出这样的源码目录结构： 如果项目规模较大，涉及多个团队协作，还可以将具有相关业务功能的页面组织在一起，形成一个子系统，进一步将整个站点拆分出多个子系统来分配给不同团队维护，针对这种情况后面我会单开文章详细介绍。 以上架构设计历经许多不同公司不同业务场景的前端团队验证，收获了不错的口碑，是行之有效的前端工程分治方案。 吐槽：我本人非常反对某些前端团队将前端开发划分为“JS开发”和“页面重构”两种岗位，更倾向于组件粒度的开发理念，对GUI软件开发的分工规划应该以功能为单位，而不是开发语言；对开发者的技术要求也应该是掌握完整的端内技术。 第二件事：“智能”静态资源管理上面提到的模块化/组件化开发，仅仅描述了一种开发理念，也可以认为是一种开发规范，倘若你认可这规范，对它的分治策略产生了共鸣，那我们就可以继续聊聊它的具体实现了。 很明显，模块化/组件化开发之后，我们最终要解决的，就是模块/组件加载的技术问题。然而前端与客户端GUI软件有一个很大的不同： 前端是一种远程部署，运行时增量下载的GUI软件 前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。 上图展示了一款界面繁多功能丰富的应用，如果采用Web实现，相信也是不小的体量，如果用户第一次访问页面就强制其加载全站静态资源再展示，相信会有很多用户因为失去耐心而流失。根据“增量”的原则，我们应该精心规划每个页面的资源加载策略，使得用户无论访问哪个页面都能按需加载页面所需资源，没访问过的无需加载，访问过的可以缓存复用，最终带来流畅的应用体验。 这正是Web应用“免安装”的魅力所在。 由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；还有复杂的BigRender、BigPipe、Quickling、PageCache等技术。这些优化方案无不围绕着如何将增量原则做到极致而展开。 所以我觉得： 第四阶段前端开发最迫切需要做好的就是在基础架构中贯彻增量原则。 相信这种贯彻不会随着时间的推移而改变，在可预见的未来，无论在HTTP1.x还是HTTP2.0时代，无论在ES5亦或者ES6/7时代，无论是AMD/CommonJS/UMD亦或者ES6 module时代，无论端内技术如何变迁，我们都有足够充分的理由要做好前端程序资源的增量加载。 正如前面说到的，第三阶段前端工程缺少点什么呢？我觉得是在其基础架构中缺少这样一种“智能”的资源加载方案。没有这样的方案，很难将前端应用的规模发展到第四阶段，很难实现落地前面介绍的那种组件化开发方案，也很难让多方合作高效率的完成一项大型应用的开发，并保证其最终运行性能良好。在第四阶段，我们需要强大的工程化手段来管理”玩具般简单“的前端开发。 在我的印象中，Facebook是这方面探索的伟大先驱之一，早在2010年的Velocity China大会上，来自Facebook的David Wei博士就为业界展示了他们令人惊艳的静态网页资源管理和优化技术。 David Wei博士在当年的交流会上提到过一些关于Facebook的一些产品数据： Facebook整站有10000+个静态资源； 每个静态资源都有可能被翻译成超过100种语言版本； 每种资源又会针对浏览器生成3种不同的版本； 要针对不同带宽的用户做5种不同的打包方法； 有3、4个不同的用户组，用于小批次体验新的产品功能； 还要考虑不同的送达方法，可以直接送达，或者通过iframe的方式提升资源并行加载的速度； 静态资源的压缩和非压缩状态可切换，用于调试和定位线上问题 这是一个状态爆炸的问题，将所有状态乘起来，整个网站的资源组合方式会达到几百万种之多（去重之后统计大概有300万种组合方式）。支撑这么大规模前端项目运行的底层架构正是魏博士在那次演讲中分享的Static Resource Management System(静态资源管理系统)，用以解决Facebook项目中有关前端工程的3D问题（Development，Deployment，Debugging）。 那段时间 FIS 项目正好遇到瓶颈，当时的FIS还是一个用php写的task-based构建工具，那时候对于前端工程的认知度很低，觉得前端构建不就是几个压缩优化校验打包任务的组合吗，写好流程调度，就针对不同需求写插件呗，看似非常简单。但当我们支撑越来越多的业务团队，接触到各种不同的业务场景时，我们深刻的感受到task-based工具的粗糙，团队每天疲于根据各种业务场景编写各种打包插件，构建逻辑异常复杂，隐隐看到不可控的迹象。 我们很快意识到把基础架构放到构建工具中实现是一件很愚蠢的事，试图依靠构建工具实现各种优化策略使得构建变成了一个巨大的黑盒，一旦发生问题，定位起来非常困难，而且每种业务场景都有不同的优化需求，构建工具只能通过静态分析来优化加载，具有很大的局限性，单页面/多页面/PC端/移动端/前端渲染/后端渲染/多语言/多皮肤/高级优化等等资源加载问题，总不能给每个都写一套工具吧，更何况这些问题彼此之间还可以有多种组合应用，工具根本写不过来。 Facebook的做法无疑为我们亮起了一盏明灯，不过可惜它并不开源（不是技术封锁，而是这个系统依赖FB体系中的其他方面，通用性不强，开源意义不大），我们只能尝试挖掘相关信息，网上对它的完整介绍还是非常非常少，分析facebook的前端代码也没有太多收获，后来无意中发现了facebook使用的项目管理工具phabricator中的一个静态管理方案Celerity，以及相关的说明，看它的描述很像是Facebook静态资源管理系统的一个mini版！ 简单看过整个系统之后发现原理并不复杂（小而美的典范），它是通过一个小工具扫描所有静态资源，生成一张资源表，然后有一个PHP实现的资源管理框架（Celerity）提供了资源加载接口，替代了传统的script/link等静态的资源加载标签，最终通过查表来加载资源。 虽然没有真正看过FB的那套系统，但眼前的这个小小的框架给了当时的我们足够多的启示： 静态资源管理系统 = 资源表 + 资源加载框架 多么优雅的实现啊！ 资源表是一份数据文件（比如JSON），是项目中所有静态资源（主要是JS和CSS）的构建信息记录，通过构建工具扫描项目源码生成，是一种k-v结构的数据，以每个资源的id为key，记录了资源的类别、部署路径、依赖关系、打包合并等内容，比如： 12345678910111213141516&#123; &quot;a.js&quot;: &#123; &quot;url&quot;: &quot;/static/js/a.5f100fa.js&quot;, &quot;dep&quot;: [ &quot;b.js&quot;, &quot;a.css&quot; ] &#125;, &quot;a.css&quot;: &#123; &quot;url&quot;: &quot;/static/css/a.63cf374.css&quot;, &quot;dep&quot;: [ &quot;button.css&quot; ] &#125;, &quot;b.js&quot;: &#123; &quot;url&quot;: &quot;/static/js/b.97193bf.js&quot; &#125;, &quot;button.css&quot;: &#123; &quot;url&quot;: &quot;/static/css/button.de33108.css&quot; &#125;&#125; 而资源加载框架则提供一些资源引用的API，让开发者根据id来引用资源，替代静态的script/link标签来收集、去重、按需加载资源。调用这些接口时，框架通过查表来查找资源的各项信息，并递归查找其依赖的资源的信息，然后我们可以在这个过程中实现各种性能优化算法来“智能”加载资源。 根据业务场景的不同，加载框架可以在浏览器中用JS实现，也可以是后端模板引擎中用服务端语言实现，甚至二者的组合，不一而足。 有关加载框架的具体实现我曾写过很多文章介绍，可以扩展阅读： 前端工程与性能优化 前端工程与模块化框架 这种设计很快被验证具有足够的灵活性，能够完美支撑不同团队不同技术规范下的性能优化需求，前面提到的按需加载、延迟加载、预加载、请求合并、文件指纹、CDN部署、Bigpipe、Quickling、BigRender、首屏CSS内嵌、HTTP 2.0服务端推送等等性能优化手段都可以很容易的在这种架构上实现，甚至可以根据性能日志自动进行优化（Facebook已实现）。 因为有了资源表，我们可以很方便的控制资源加载，通过各种手段在运行时计算页面的资源使用情况，从而获得最佳加载性能。无论是前端渲染的单页面应用，还是后端渲染的多页面应用，这种方法都同样适用。 此外，它还很巧妙的约束了构建工具的职责——只生成资源表。资源表是非常通用的数据结构，无论什么业务场景，其业务代码最终都可以被扫描为相同结构的表数据，并标记资源间的依赖关系，有了表之后我们只需根据不同的业务场景定制不同的资源加载框架就行了，从此彻底告别一个团队维护一套工具的时代！！！ 恩，如你所见，虽然彻底告别了一个团队一套工具的时代，但似乎又进入了一个团队一套框架的时代。其实还是有差别的，因为框架具有很大的灵活性，而且不那么黑盒，采用框架实现资源管理相比构建更容易调试、定位和升级变更。 深耕静态资源加载框架可以带来许多收益，而且有足够的灵活性和健壮性面向未来的技术变革，这个我们留作后话。 总结回顾一下前面提到过的前端工程三个阶段： 第一阶段：库/框架选型 第二阶段：简单构建优化 第三阶段：JS/CSS模块化开发 现在补充上第四阶段： 第四阶段：组件化开发与资源管理 由于先天缺陷，前端相比其他软件开发，在基础架构上更加迫切的需要组件化开发和资源管理，而解决资源管理的方法其实一点也不复杂： 一个通用的资源表生成工具 + 基于表的资源加载框架 近几年来各种你听到过的各种资源加载优化策略大部分都可以在这样一套基础上实现，而这种优化对于业务来说是完全透明的，不需要重构的性能优化——这不正是我们一直所期盼的吗？正如魏小亮博士所说：我们可以把优秀的人集中起来去优化加载。 如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说： 你好，工程师！ 前端工程其实是一个很大的话题，开发仅是其中的一部分。 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/前端工程/2017/03/02/何为web前端？前端工程分哪些阶段？.html]]></content>
      <categories>
        <category>前端工程</category>
      </categories>
      <tags>
        <tag>前端工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js函数作用域与this的指向问题]]></title>
    <url>%2FJavaScript%2F2017%2F03%2F02%2FJs%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8Ethis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[以前对函数作用域以及this指向都没有一个系统的认识，偶然一次代码编写运行结果与自己预想结果不一样，这让我决定对Js的作用域和this深层次学习。下面是我当初的一个小错误： 123456789var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;, 1000) &#125;&#125;obj.getA(); 这里输出的undefined，因为这里的this指向window。只需要修改this指向就可以，方法很多。 12345678var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;.bind(this), 1000) &#125;&#125; 首先需要了解这些重要概念： 基础数据类型与引用数据类型 内存空间 垃圾回收机制 执行上下文 变量对象与活动对象 作用域 JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。 作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。下面请允许我盗一张图：来自波同学。 我理解作用域是：函数名以及变量或者anguments所能访问或查找的规则，或者叫所能访问到内存区块。优先级是anguments-&gt;function表达式-&gt;var。变量在声明它们的函数体内(或嵌套函数内)任意地方都是有定义的。下面看一份代码： 1234567var scope="global";function t()&#123; console.log(scope); var scope="local" console.log(scope);&#125;t(); 第一句输出的是： “undefined”，而不是 “global”第二讲输出的是：”local”你可能会认为第一句会输出：”global”,因为代码还没执行var scope=”local”,所以肯定会输出“global”。上面已经讲过，变量在函数体内任意地方都是有定义的。在函数作用域创建阶段，首先会先生成变量对象VO：VO包括anguments、function、var变量的创建。到了函数执行阶段包括变量开始赋值、执行上下文this确定、代码执行。在第一句console.log打印时，函数作用域内只有var scope，scope并没有赋值。可以理解为下面代码： 12345678var scope="global";function t()&#123; var scope; console.log(scope); scope="local" console.log(scope);&#125;t(); 在此看来，由于函数作用域的特性，局部变量在整个函数体始终是由定义的，我们可以将变量声明”提前“到函数体顶部，同时变量初始化还在原来位置。 作用域链这里来看一下执行上下文的生命周期：从创建–&gt;执行代码–&gt;执行完毕，出栈等待被回收。 这里可以将作用域和作用域链结合起来理解：作用域是一块能够查询到的内存区域或者查询规则；作用域链，是对查询规则的实现或者内存寻址的过程，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 1234567891011121314151617var a = 20;function test() &#123; var b = a + 10; function innerTest() &#123; var c = 10; return b + c; &#125; return innerTest();&#125;test();//innerTest的执行上下文创建阶段如下：innerTestEC = &#123; VO: &#123;...&#125;, // 变量对象 scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链 this: &#123;&#125;&#125; 因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object 顺便理解一下闭包，简单来说，假设函数A在函数B的内部进行定义了，并且当函数A在执行时，访问了函数B内部的变量对象，那么B就是一个闭包。概述为：当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行。有一下特点： 闭包与作用域链息息相关。 闭包是在函数执行过程中被确认。 通过闭包，我们可以在其他的执行上下文中，访问到其函数的内部变量 闭包案例：利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125; 简单修改为：（相信你可以更多其他方法） 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( (function() &#123; console.log(i); &#125;)(i), i*1000 );&#125; 最后输出的7是setTimeout计时器的ID，计时器一般会生成一个唯一id，用于清除时用。 this的指向理解 this的指向，是在函数被调用的时候确定的 全局对象中的this关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。 12345678910111213// 通过this绑定到全局对象this.a2 = 20;// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身var a1 = 10;// 仅仅只有赋值操作，标识符会隐式绑定到全局对象a3 = 30;// 输出结果会全部符合预期console.log(a1);console.log(a2);console.log(a3); 函数中的this1234567891011121314151617181920212223242526// demo01var a = 20;function fn() &#123; console.log(this.a);&#125;fn();// demo02var a = 20;function fn() &#123; function foo() &#123; console.log(this.a); &#125; foo();&#125;fn();// demo03var a = 20;var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125;&#125;console.log(obj.c);console.log(obj.fn()); 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。 当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象 使用call，apply显示指定this call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同 123456789function fn(num1, num2) &#123; console.log(this.a + num1 + num2);&#125;var obj = &#123; a: 20&#125;fn.call(obj, 100, 10); // 130fn.apply(obj, [20, 10]); // 50 实现继承 1234567891011121314151617181920212223// 定义父级的构造函数var Person = function(name, age) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman'];&#125;// 定义子类的构造函数var Student = function(name, age, high) &#123; // use call Person.call(this, name, age); this.high = high;&#125;Student.prototype.message = function() &#123; console.log('name:'+this.name+', age:'+this.age+', high:'+this.high+', gender:'+this.gender[0]+';');&#125;new Student('xiaom', 12, '150cm').message();// result// ----------// name:xiaom, age:12, high:150cm, gender:man; 在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了基层。 1234567 var Student = function(name, age, high) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman']; // Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承 this.high = high;&#125; 构造函数与原型方法上的this 这是面向对象编程的核心要点，直接上代码 1234567891011121314151617function Person(name, age) &#123; // 这里的this指向了谁? this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; // 这里的this又指向了谁？ return this.name;&#125;// 上面的2个this，是同一个吗，他们是否指向了原型对象？var p1 = new Person('Nick', 20);p1.getName(); 通过new操作符调用构造函数，会经历以下4个阶段。 创建一个新的对象； 将构造函数的this指向这个新对象； 指向构造函数的代码，为这个对象添加属性，方法等； 返回新对象 基本上prototype对象指向new操作符生成的实例，这里指向p1。 查阅资料：感谢波同学的分享csdn的一篇博客 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/JavaScript/2017/03/02/Js函数作用域与this的指向问题.html]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端兼容性解决方案汇总]]></title>
    <url>%2FMobile%2F2017%2F02%2F28%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86.html</url>
    <content type="text"><![CDATA[关于移动端的兼容性问题的解决方案，希望码友们踊跃分享，让移动端的坑无所遁形 1. IOS移动端click事件300ms的延迟响应移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。这是由于区分单击事件和双击屏幕缩放的历史原因造成的, 2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接a标签，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题 触摸事件的响应顺序为 touchstart –&gt; touchmove –&gt; touchend –&gt; click,也可以通过绑定ontouchstart事件，加快对事件的响应，解决300ms延迟问题 2.一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了。3. 三星手机遮罩层下的input、select、a等元素可以被点击和focus(点击穿透)问题发现于三星手机，这个在特定需求下才会有，因此如果没有类似问题的可以不看。首先需求是浮层操作，在三星上被遮罩的元素依然可以获取focus、click、change)，有两种解决方案， 1.是通过层显示以后加入对应的class名控制，截断显示层下方可获取焦点元素的事件获取 2.是通过将可获取焦点元素加入的disabled属性，也可以利用属性加dom锁定的方式（disabled的一种变换方式） 4. h5底部输入框被键盘遮挡问题h5页面有个很蛋疼的问题就是，当输入框在最底部，点击软键盘后输入框会被遮挡。可采用如下方式解决 12345678910111213var oHeight = $(document).height(); //浏览器当前的高度 $(window).resize(function()&#123; if($(document).height() &lt; oHeight)&#123; $(&quot;#footer&quot;).css(&quot;position&quot;,&quot;static&quot;); &#125;else&#123; $(&quot;#footer&quot;).css(&quot;position&quot;,&quot;absolute&quot;); &#125; &#125;); 关于Web移动端Fixed布局的解决方案，这篇文章也不错 5.不让 Android 手机识别邮箱1&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt; 6.禁止 iOS 识别长串数字为电话1&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt; 7.禁止 iOS 弹出各种操作窗口1-webkit-touch-callout:none 8.消除 transition 闪屏12-webkit-transform-style: preserve-3d; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/-webkit-backface-visibility: hidden; /*(设置进行转换的元素的背面在面对用户时是否可见：隐藏)*/ 9.iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格可以通过正则去掉 this.value = this.value.replace(/\u2006/g, &#39;&#39;); 10.禁止ios和android用户选中文字 -webkit-user-select:none 11.在ios和andriod中,audio元素和video元素在无法自动播放应对方案：触屏即播 123$(&apos;html&apos;).one(&apos;touchstart&apos;,function()&#123; audio.play()&#125;) 12.ios下取消input在输入的时候英文首字母的默认大写1&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt; 13.android下取消输入语音按钮1input::-webkit-input-speech-button &#123;display: none&#125; 14 CSS动画页面闪白,动画卡顿1234567解决方法:1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位2.开启硬件加速 -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); 15.fixed定位缺陷 ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位 android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 ios4下不支持position:fixed 解决方案： 可用iScroll插件解决这个问题 16.阻止旋转屏幕时自动调整字体大小1html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123;-webkit-text-size-adjust:none;&#125; 17. Input 的placeholder会出现文本位置偏上的情况input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal 18. 往返缓存问题点击浏览器的回退，有时候不会自动执行js，特别是在mobilesafari中。这与往返缓存(bfcache)有关系。 1解决方法 ：window.onunload = function()&#123;&#125;; 19. calc的兼容性处理CSS3中的calc变量在iOS6浏览器中必须加-webkit-前缀，目前的FF浏览器已经无需-moz-前缀。Android浏览器目前仍然不支持calc，所以要在之前增加一个保守尺寸： 12345div &#123; width: 95%; width: -webkit-calc(100% - 50px); width: calc(100% - 50px);&#125; 20. iOS6下伪类:hover除了之外的元素无效；在Android下则有效。类似 1div#topFloatBar_l:hover #topFloatBar_menu &#123; display:block; &#125; 这样的导航显示在iOS6点击没有点击效果，只能通过增加点击侦听器给元素增减class来控制子元素。 21. 在移动端修改难看的点击的高亮效果，iOS和安卓下都有效：1* &#123;-webkit-tap-highlight-color:rgba(0,0,0,0);&#125; 不过这个方法在现在的安卓浏览器下，只能去掉那个橙色的背景色，点击产生的高亮边框还是没有去掉，有待解决！ 一个CSS3的属性，加上后，所关联的元素的事件监听都会失效，等于让元素变得“看得见，点不着”。IE到11才开始支持，其他浏览器的当前版本基本都支持。详细介绍见这里：https://developer.mozilla.org/zh-CN/docs/Web/CSS/pointer-events 1pointer-events: none; 22. Zepto点透的解决方案zepto的tap是通过兼听绑定在document上的touch事件来完成tap事件的模拟的,及tap事件是冒泡到document上触发的,在点击完成时的tap事件(touchstart\touchend)需要冒泡到document上才会触发，而在冒泡到document之前，用户手的接触屏幕(touchstart)和离开屏幕(touchend)是会触发click事件的,因为click事件有延迟触发(这就是为什么移动端不用click而用tap的原因)(大概是300ms,为了实现safari的双击事件的设计)，所以在执行完tap事件之后，弹出来的选择组件马上就隐藏了，此时click事件还在延迟的300ms之中，当300ms到来的时候，click到的其实不是完成而是隐藏之后的下方的元素，如果正下方的元素绑定的有click事件此时便会触发，如果没有绑定click事件的话就当没click，但是正下方的是input输入框(或者select选择框或者单选复选框)，点击默认聚焦而弹出输入键盘，也就出现了上面的点透现象。 引入fastclick.js，在页面中加入如下js代码 123window.addEventListener( &quot;load&quot;, function() &#123; FastClick.attach( document.body );&#125;, false ); 或者有zepto或者jQuery的js里面加上 123$(function() &#123; FastClick.attach(document.body);&#125;); 当然require的话就这样： 12var FastClick = require(&apos;fastclick&apos;);FastClick.attach(document.body, options); 方案二：用touchend代替tap事件并阻止掉touchend的默认行为preventDefault() 1234$(&quot;#cbFinish&quot;).on(&quot;touchend&quot;, function (event) &#123; //很多处理比如隐藏什么的 event.preventDefault();); 方案三：延迟一定的时间(300ms+)来处理事件 12345$(&quot;#cbFinish&quot;).on(&quot;tap&quot;, function (event) &#123; setTimeout(function()&#123; //很多处理比如隐藏什么的 &#125;,320);&#125;); 23.外观A.页面高度渲染错误 在各移动端浏览器中经常会出现这种页面高度100%的渲染错误，页面低端和系统自带的导航条重合了，高度的不正确我们需要重置修正它，通过javascript代码重置掉： document.documentElement.style.height = window.innerHeight + ‘px’; B.叠加区高亮 在部分android机型中点击页面某一块区域可能会出现如图所示的黄色框秒闪，这是部分机型系统自身的默认定制样式，给该元素一个CSS样式重置掉： -webkit-tap-highlight-color:rgba(0,0,0,0); 24.行为A、事件无法被触发 在部分android机型的微信环境中会出现事件无法触发、表单无法输入的情况，我们针对需要输入或者触发事件的元素设置样式：-webkit-transform: translate3d(0,0,0) ，不过新版本的微信已经直接修复了该问题。 B、:active 效果不兼容 在android 4.0版本以下CSS :active伪状态效果无法兼容，我们给该元素的touch系列的事件（touchstart/touchend/touchmove）绑定一个空匿名方法: var element=document.getElementsById(”btnShare”);element.addEventListener(‘touchstart’,function(){},false); 25.应用A、浏览器崩溃 12345var act = function()&#123; window.removeEventListener(&apos;devicemotion&apos;,act);&#125;;window.addEventListener(&apos;devicemotion&apos;,act,false); 解绑函数写在了事件处理中导致小米手机中的微信崩溃，那么我们不要将解绑时间写在事件处理中即可。 B、预加载、自动播放无效 如上表所示，经过简单的测试发现预加载、自动播放的有效性受操作系统、浏览器（webview）、版本等的影响，苹果官方规定必须由用户手动触发才会载入音频，那么我们捕捉一次用户输入后，让音频加载实现预加载: 123456789//play and pause it oncedocument.addEventListener(&apos;touchstart&apos;, function () &#123; document.getElementsByTagName(&apos;audio&apos;)[0].play(); document.getElementsByTagName(&apos;audio&apos;)[0].pause();&#125;); C、无法同时播放多音频 在android设备中,播放后一音频会打断前一音频，而不会同步播放,这个是目前系统资深决定的，我们只有采取优雅降权的方法让android选择不一样风格的音频前后切换播放而不是同时播放，达到与预期接近的音频效果。 D、不支持局部滚动 在android 4.0版本以下在body(html)元素之外的元素 overflow:scroll 样式设置滚动条无效，这里有两种解决方案: 1、巧用布局直接设置样式滚动条在body(html)上，其他元素“错觉滚动”。 2、利用iscroll、自写js控制translate、scrollTop模拟 26.系统/硬件A、怪异悬浮的表单 在部分android 机型中的输入框可能会出现如图怪异的多余的浮出表单，经过观察与测试发现只有input:password类型的输入框存在，那么我们只要使用input:text类型的输入框并通过样式-webkit-text-security: disc; 隐藏输入密码从而解决。 B、错误出现滚动条 在游戏内嵌页中出现了不应该出现的滚动条，而且内容并没有超出内容区宽度，经过测试overflow:hidden 无效，通过一系列尝试使用古老的 写法解决，多尝试一下不同的写法和属性会有不一样的惊喜哦！ C、链接打开系统浏览器 在游戏内webview的部分android机型中可能会出现点击链接调用系统浏览器的情况，这是一个非常不好的体验。那么我们尝试给这个元素添加 target=”_blank”‘ 属性有可能解决，如果还不能解决那么需要修改IOS或android原生系统函数了。 D、Flex box 不兼容 在游戏内嵌webview中碰到Flex box布局不兼容的情况，图中所示下面部分的导航错位了，虽然之前有仔细查看过Flex box的兼容性，但是在游戏内嵌页中无法确定其调用的系统浏览器版本及兼容，所以导致错误，所以我们写完整历史版本呢的3种Flex box 解决。那么我们思考在写页面过程中还是本着保守稳定的方式书写样式可以减少不不要的麻烦。 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/Mobile/2017/02/28/移动端兼容性问题收集.html]]></content>
      <categories>
        <category>Mobile</category>
      </categories>
      <tags>
        <tag>移动端兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端Swig模版快速入门]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%2F2017%2F02%2F27%2Fswig%E6%A8%A1%E7%89%88%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[Swig官网文档经常404打不开，网上Swig模版在前端的中文资料非常少，这里也是 摘录网上的一部分资料，乐于分享的朋友可以留言哦。不过对于想要修改 Hexo-Next博客的朋友，相信看了这篇文章的朋友能够大概知道使用技巧。 后续我也会整理一下Swig模版的基本资料。 如何使用Swig优点： 支持大多数主流浏览器。 表达式兼容性好。 面向对象的模板继承。 将过滤器和转换应用到模板中的输出。 可根据路劲渲染页面。 支持页面复用。 支持动态页面。 可扩展、可定制。 API1234567891011swig.init(&#123; allowErrors: false, autoescape: true, cache: true, encoding: &apos;utf8&apos;, filters: &#123;&#125;, root: &apos;/&apos;, tags: &#123;&#125;, extensions: &#123;&#125;, tzOffset: 0&#125;); options: allowErrors:默认值为 false。将所有模板解析和编译错误直接输出到模板。如果为 true，则将引发错误，抛出到 Node.js 进程中，可能会使您的应用程序崩溃。 autoescape:默认true，强烈建议保持。字符转换表请参阅转义过滤器。 true: HTML安全转义false: 不转义，除非使用转义过滤器或者转义标签‘js’: js安全转义 cache:更改为 false 将重新编译每个请求的模板的文件。正式环境建议保持true。 encoding模板文件编码 root需要搜索模板的目录。如果模板传递给 swig.compileFile 绝对路径(以/开头)，Swig不会在模板root中搜索。如果传递一个数组，使用第一个匹配成功的数组项。 tzOffset设置默认时区偏移量。此设置会使转换日期过滤器会自动的修正相应时区偏移量。 filters 自定义过滤器或者重写默认过滤器，参见自定义过滤器指南。 tags自定义标签或者重写默认标签，参见自定义标签指南。 extensions 添加第三方库，可以在编译模板时使用，参见参见自定义标签指南。 nodejs12var tpl = swig.compileFile(&quot;path/to/template/file.html&quot;);var renderedHtml = tpl.render(&#123; vars: &apos;to be inserted in template&apos; &#125;); or 12var tpl = swig.compile(&quot;Template string here&quot;);var renderedHtml = tpl(&#123; vars: &apos;to be inserted in template&apos; &#125;); 结合Express12npm install expressnpm install consolidate 然后 12app.engine(&apos;.html&apos;, cons.swig);app.set(&apos;view engine&apos;, &apos;html&apos;); 浏览器Swig浏览器版本的api基本与nodejs版相同，不同点如下： 不能使用swig.compileFile，浏览器没有文件系统 你必须提前使用swig.compile编译好模板 按顺序使用extends, import, and include，同时在swig.compile里使用参数templateKey来查找模板 12var template = swig.compile(&apos;&lt;p&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/p&gt;&apos;, &#123; filename: &apos;main&apos; &#125;);var mypage = swig.compile(&apos;&#123;% extends &quot;main&quot; %&#125;&#123;% block content %&#125;Oh hey there!&#123;% endblock %&#125;&apos;, &#123; filename: &apos;mypage&apos; &#125;); 基础变量12&#123;&#123; foo.bar &#125;&#125;&#123;&#123; foo[&apos;bar&apos;] &#125;&#125; 如果变量未定义，输出空字符。 变量可以通过过滤器来修改： 12&#123;&#123; name|title &#125;&#125; was born on &#123;&#123; birthday|date(&apos;F jS, Y&apos;) &#125;&#125;// Jane was born on July 6th, 1985 逻辑标签参见标签部分。 注释空白模板里的空白在最终输出时默认保留，如果需要去掉空白，可以在逻辑标签前后加上空白控制服-： 123&#123;% for item in seq -%&#125; &#123;&#123; item &#125;&#125;&#123;%- endfor %&#125; 模板继承Swig 使用 extends 和 block 来实现模板继承 layout.html 1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&#123;% block title %&#125;My Site&#123;% endblock %&#125;&lt;/title&gt; &#123;% block head %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; &#123;% block content %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; index.html 123456789101112&#123;% extends &apos;layout.html&apos; %&#125;&#123;% block title %&#125;My Page&#123;% endblock %&#125;&#123;% block head %&#125;&#123;% parent %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;custom.css&quot;&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;p&gt;This is just an awesome page.&lt;/p&gt;&#123;% endblock %&#125; 变量过滤器用于修改变量。变量名称后用 | 字符分隔添加过滤器。您可以添加多个过滤器。 例子12&#123;&#123; name|title &#125;&#125; was born on &#123;&#123; birthday|date(&apos;F jS, Y&apos;) &#125;&#125;and has &#123;&#123; bikes|length|default(&quot;zero&quot;) &#125;&#125; bikes. 也可以使用 filter 标签来为块内容添加过滤器 1&#123;% filter upper %&#125;oh hi, paul&#123;% endfilter %&#125; 内置过滤器 add(value)使变量与value相加，可以转换为数值字符串会自动转换为数值。 addslashes用 \ 转义字符串 capitalize大写首字母 date(format[, tzOffset])转换日期为指定格式 format： 格式tzOffset： 时区 default(value)默认值（如果变量为undefined，null，false） e同escape escape([type])转义字符 默认： &amp;, &lt;, &gt;, “, ‘js: &amp;, &lt;, &gt;, “, ‘, =, -, ; first返回数组第一个值 join(glue)同[].join json_encode([indent])类似JSON.stringify, indent为缩进空格数 last返回数组最后一个值 length返回变量的length，如果是object，返回key的数量 lower同’’.toLowerCase() raw指定输入不会被转义 replace(search, replace[, flags])同’’.replace reverse翻转数组 striptags去除html/xml标签 title大写首字母 uniq数组去重 upper同’’.toUpperCase url_encode同encodeURIComponent url_decode同decodeURIComponemt 自定义过滤器创建一个 myfilter.js 然后引入到 Swig 的初始化函数中 1swig.init(&#123; filters: require(&apos;myfilters&apos;) &#125;); 在 myfilter.js 里，每一个 filter 方法都是一个简单的 js 方法，下例是一个翻转字符串的 filter： 123exports.myfilter = function (input) &#123; return input.toString().split(&apos;&apos;).reverse().join(&apos;&apos;);&#125;; 你的 filter 一旦被引入，你就可以向下面一样使用： 123&#123;&#123; name|myfilter &#125;&#125;&#123;% filter myfilter %&#125;I shall be filtered&#123;% endfilter %&#125; 你也可以像下面一样给 filter 传参数： 12345678exports.prefix = function(input, prefix) &#123; return prefix.toString() + input.toString();&#125;;&#123;&#123; name|prefix(&apos;my prefix&apos;) &#125;&#125;&#123;% filter prefix &apos;my prefix&apos; %&#125;I will be prefixed with &quot;my prefix&quot;.&#123;% endfilter %&#125;&#123;% filter prefix foo %&#125;I will be prefixed with the value stored to `foo`.&#123;% endfilter %&#125; 标签内置标签 extends使当前模板继承父模板，必须在文件最前 参数：file:父模板相对模板 root 的相对路径 block定义一个块，使之可以被继承的模板重写，或者重写父模板的同名块 参数：name:块的名字，必须以字母数字下划线开头 parent将父模板中同名块注入当前块中 include包含一个模板到当前位置，这个模板将使用当前上下文 参数：file:包含模板相对模板 root 的相对路径ignore missing:包含模板不存在也不会报错with x:设置 x 至根上下文对象以传递给模板生成。必须是一个键值对only:限制模板上下文中用 with x 定义的参数 1234&gt; &#123;% include template_path %&#125;&gt; &#123;% include &quot;path/to/template.js&quot; %&#125;&gt;&gt; &gt; 你可以标记 ignore missing，这样如果模板不存在，也不会抛出错误 123&gt; &#123;% include &quot;foobar.html&quot; ignore missing %&#125;&gt;&gt; &gt; 本地声明的上下文变量，默认情况不会传递给包含的模板。例如以下情况，inc.html 无法得到 foo 和 bar 12345678&gt; &#123;% set foo = &quot;bar&quot; %&#125;&gt; &#123;% include &quot;inc.html&quot; %&#125;&gt;&gt; &#123;% for bar in thing %&#125;&gt; &#123;% include &quot;inc.html&quot; %&#125;&gt; &#123;% endfor %&#125;&gt;&gt; &gt; 如果想把本地声明的变量引入到包含的模板种，可以使用 with 参数来把后面的对象创建到包含模板的上下文中 12345678&gt; &#123;% set foo = &#123; bar: &quot;baz&quot; &#125; %&#125;&gt; &#123;% include &quot;inc.html&quot; with foo %&#125;&gt;&gt; &#123;% for bar in thing %&#125;&gt; &#123;% include &quot;inc.html&quot; with bar %&#125;&gt; &#123;% endfor %&#125;&gt;&gt; &gt; 如果当前上下文中 foo 和 bar 可用，下面的情况中，只有 foo 会被 inc.html 定义 123&gt; &#123;% include &quot;inc.html&quot; with foo only %&#125;&gt;&gt; &gt; only 必须作为最后一个参数，放在其他位置会被忽略 raw停止解析标记中任何内容，所有内容都将输出 参数：file:父模板相对模板 root 的相对路径 for遍历对象和数组 参数：x:当前循环迭代名in:语法标记y:可迭代对象。可以使用过滤器修改 1234567&gt; &#123;% for x in y %&#125;&gt; &#123;% if loop.first %&#125;&lt;ul&gt;&#123;% endif %&#125;&gt; &lt;li&gt;&#123;&#123; loop.index &#125;&#125; - &#123;&#123; loop.key &#125;&#125;: &#123;&#123; x &#125;&#125;&lt;/li&gt;&gt; &#123;% if loop.last %&#125;&lt;/ul&gt;&#123;% endif %&#125;&gt; &#123;% endfor %&#125;&gt;&gt; &gt; 特殊循环变量loop.index：当前循环的索引（1开始）loop.index0：当前循环的索引（0开始）loop.revindex：当前循环从结尾开始的索引（1开始）loop.revindex0：当前循环从结尾开始的索引（0开始）loop.key：如果迭代是对象，是当前循环的键，否则同 loop.indexloop.first：如果是第一个值返回 trueloop.last：如果是最后一个值返回 trueloop.cycle：一个帮助函数，以指定的参数作为周期 12345&gt; &#123;% for item in items %&#125;&gt; &lt;li class=&quot;&#123;&#123; loop.cycle(&apos;odd&apos;, &apos;even&apos;) &#125;&#125;&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;&gt; &#123;% endfor %&#125;&gt;&gt; &gt; 在 for 标签里使用 else 1234567&gt; &#123;% for person in people %&#125;&gt; &#123;&#123; person &#125;&#125;&gt; &#123;% else %&#125;&gt; There are no people yet!&gt; &#123;% endfor %&#125;&gt;&gt; &gt; if条件语句 参数：…:接受任何有效的 JavaScript 条件语句，以及一些其他人类可读语法 123456789101112131415161718192021222324252627&gt; &#123;% if x %&#125;&#123;% endif %&#125;&gt; &#123;% if !x %&#125;&#123;% endif %&#125;&gt; &#123;% if not x %&#125;&#123;% endif %&#125;&gt;&gt; &#123;% if x and y %&#125;&#123;% endif %&#125;&gt; &#123;% if x &amp;&amp; y %&#125;&#123;% endif %&#125;&gt; &#123;% if x or y %&#125;&#123;% endif %&#125;&gt; &#123;% if x || y %&#125;&#123;% endif %&#125;&gt; &#123;% if x || (y &amp;&amp; z) %&#125;&#123;% endif %&#125;&gt;&gt; &#123;% if x [operator] y %&#125;&gt; Operators: ==, !=, &lt;, &lt;=, &gt;, &gt;=, ===, !==&gt; &#123;% endif %&#125;&gt;&gt; &#123;% if x == &apos;five&apos; %&#125;&gt; The operands can be also be string or number literals&gt; &#123;% endif %&#125;&gt;&gt; &#123;% if x|length === 3 %&#125;&gt; You can use filters on any operand in the statement.&gt; &#123;% endif %&#125;&gt;&gt; &#123;% if x in y %&#125;&gt; If x is a value that is present in y, this will return true.&gt; &#123;% endif %&#125;&gt;&gt; &gt; else 和 else if 123456789&gt; &#123;% if foo %&#125;&gt; Some content.&gt; &#123;% else if &quot;foo&quot; in bar %&#125;&gt; Content if the array `bar` has &quot;foo&quot; in it.&gt; &#123;% else %&#125;&gt; Fallback content.&gt; &#123;% endif %&#125;&gt;&gt; &gt; autoescape改变当前变量的自动转义行为 参数：on:当前内容是否转义type:转义类型，js 或者 html，默认 html 假设 123&gt; some_html_output = &apos;&lt;p&gt;Hello &quot;you&quot; &amp; \&apos;them\&apos;&lt;/p&gt;&apos;;&gt;&gt; &gt; 然后 12345678910111213&gt; &#123;% autoescape false %&#125;&gt; &#123;&#123; some_html_output &#125;&#125;&gt; &#123;% endautoescape %&#125;&gt;&gt; &#123;% autoescape true %&#125;&gt; &#123;&#123; some_html_output &#125;&#125;&gt; &#123;% endautoescape %&#125;&gt;&gt; &#123;% autoescape true &quot;js&quot; %&#125;&gt; &#123;&#123; some_html_output &#125;&#125;&gt; &#123;% endautoescape %&#125;&gt;&gt; &gt; 将会输出 1234567&gt; &lt;p&gt;Hello &quot;you&quot; &amp; &apos;them&apos;&lt;/p&gt;&gt;&gt; &amp;lt;p&amp;gt;Hello &amp;quot;you&amp;quot; &amp;amp; &amp;#39;them&amp;#39; &amp;lt;/p&amp;gt;&gt;&gt; \u003Cp\u003EHello \u0022you\u0022 &amp; \u0027them\u0027\u003C\u005Cp\u003E&gt;&gt; &gt; set设置一个变量，在当前上下文中复用 参数：name:变量名=:语法标记value:变量值 123456&gt; &#123;% set foo = [0, 1, 2, 3, 4, 5] %&#125;&gt; &#123;% for num in foo %&#125;&gt; &lt;li&gt;&#123;&#123; num &#125;&#125;&lt;/li&gt;&gt; &#123;% endfor %&#125;&gt;&gt; &gt; macro创建自定义可服用的代码段 参数：…:用户定义 123456&gt; &#123;% macro input type name id label value error %&#125;&gt; &lt;label for=&quot;&#123;&#123; name &#125;&#125;&quot;&gt;&#123;&#123; label &#125;&#125;&lt;/label&gt;&gt; &lt;input type=&quot;&#123;&#123; type &#125;&#125;&quot; name=&quot;&#123;&#123; name &#125;&#125;&quot; id=&quot;&#123;&#123; id &#125;&#125;&quot; value=&quot;&#123;&#123; value &#125;&#125;&quot;&#123;% if error %&#125; class=&quot;error&quot;&#123;% endif %&#125;&gt;&gt; &#123;% endmacro %&#125;&gt;&gt; &gt; 然后像下面使用 1234&gt; &lt;div&gt;&#123;&#123; input(&quot;text&quot;, &quot;fname&quot;, &quot;fname&quot;, &quot;First Name&quot;, fname.value, fname.errors) &#125;&#125;&lt;/div&gt;&gt; &lt;div&gt;&#123;&#123; input(&quot;text&quot;, &quot;lname&quot;, &quot;lname&quot;, &quot;Last Name&quot;, lname.value, lname.errors) &#125;&#125;&lt;/div&gt;&gt;&gt; &gt; 输出如下 12345678910&gt; &lt;div&gt;&gt; &lt;label for=&quot;fname&quot;&gt;First Name&lt;/label&gt;&gt; &lt;input type=&quot;text&quot; name=&quot;fname&quot; id=&quot;fname&quot; value=&quot;Paul&quot;&gt;&gt; &lt;/div&gt;&gt; &lt;div&gt;&gt; &lt;label for=&quot;lname&quot;&gt;Last Name&lt;/label&gt;&gt; &lt;input type=&quot;text&quot; name=&quot;lname&quot; id=&quot;lname&quot; value=&quot;&quot; class=&quot;error&quot;&gt;&gt; &lt;/div&gt;&gt;&gt; &gt; import允许引入另一个模板的宏进入当前上下文 参数：file:引入模板相对模板 root 的相对路径as:语法标记 var: 分配给宏的可访问上下文对象 123456789&gt; &#123;% import &apos;formmacros.html&apos; as form %&#125;&gt;&gt; &#123;# this will run the input macro #&#125;&gt; &#123;&#123; form.input(&quot;text&quot;, &quot;name&quot;) &#125;&#125;&gt;&gt; &#123;# this, however, will NOT output anything because the macro is scoped to the &quot;form&quot; object: #&#125;&gt; &#123;&#123; input(&quot;text&quot;, &quot;name&quot;) &#125;&#125;&gt;&gt; &gt; filter对整个块应用过滤器 参数：filter_name:过滤器名字 … :若干传给过滤器的参数 父模板相对模板 root 的相对路径 1234&gt; &#123;% filter uppercase %&#125;oh hi, &#123;&#123; name &#125;&#125;&#123;% endfilter %&#125;&gt; &#123;% filter replace &quot;.&quot; &quot;!&quot; &quot;g&quot; %&#125;Hi. My name is Paul.&#123;% endfilter %&#125;&gt;&gt; &gt; 输出 1234&gt; OH HI, PAUL&gt; Hi! My name is Paul!&gt;&gt; &gt; spaceless尝试移除html标签间的空格 1234567&gt; &#123;% spaceless %&#125;&gt; &#123;% for num in foo %&#125;&gt; &lt;li&gt;&#123;&#123; loop.index &#125;&#125;&lt;/li&gt;&gt; &#123;% endfor %&#125;&gt; &#123;% endspaceless %&#125;&gt;&gt; &gt; 输出 123&gt; &lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&gt;&gt; ** 不满足于此吗？想知道详细资料的请您移步Github。 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/技术分享/2017/02/27/swig模版快速入门.html]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Swig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[勿忘初心]]></title>
    <url>%2FMood-Diary%2F2017%2F02%2F24%2F%E5%8B%BF%E5%BF%98%E5%88%9D%E5%BF%83.html</url>
    <content type="text"><![CDATA[闲了就会思索，思索就会感慨，有很多人感到失落，感慨没有好好珍惜自己的生命。 一辈子很长，随着时间的流逝，过往的历练让我们变得成熟和精明，成熟的你会感到以前很是幼稚，看透了世俗，想穿了一切，于是，我们就此变成了自己年少时所最憎恶的那种人。一辈子仿若又很短，所有的委屈、愤懑都是浮云，要保持那份初心确实着实不易。 万事万物都有它存在的方式，我们能做的就是勿忘初心，只有寄浮于天地，坚持本真的善良和最初的梦想，学会尊重他人和自己的初心，处理好和社会的关系，才会不枉此生。 有人说：“只有在轻狂少年时才敢妄谈梦想，不计一切的去实现它，只因我们输得起，无所牵挂，一旦年华老去，变得心有挂碍后，便再无法前进一步。”还有人说：“人生就是在自己走的路上，慢慢地让自己开始变老。”我不赞成这样的消极观点，这样对自己不负责，活着也将若枯木，我们实现不了梦想，只因我们忘却了初心；选择去忘记这最初的梦想，是惧怕于现实太过残酷，将之付诸实现的代价太大。 哪怕此时此刻我们还是无法踏上征途，那么至少在红尘中，我们的初心还好好地在心中珍藏，不让它因岁月的冲刷而斑驳失色；静静的等到时机到来的那一刻，带上我们的梦想出发，一如当初的少年。勿忘初心，方得终始，不忘记自己最初的想法，才能有始有终地去完成自己的梦想。 每个人或大或小总有梦想，追梦的路上怎能不磕磕绊绊，追 梦的路上又岂会一帆风顺？那些想去的地方，未完成的事，即使天寒地冻，山高路远，也请勿忘初心，你要遵守的是你的心，你心中那份不朽的热爱，那份坚定不移的自我本真之美，始终如一，不抛弃，不放弃，总有一天你会看到心中的那份光亮！只要努力，我们就能一步步确实的接近我们的梦。不管我们的梦要在何时结束，只要我们还能去心无挂碍地寻梦，就要一往无前的进发。哪怕等到年华老去，被世俗枷锁而无力寻梦，我们也依旧未能成功；至少我们还留下了一份值得在人生的秋季里回味与自豪的记忆。 勿忘初心，方得终始，发自内心的感觉，是判断事物的可靠的证据，而真正的善良就是尊重自己的那份原始的感受。要知道心若改变，性格就会随着改变;性格改变，人生亦跟着改变。更多的时候我们能做的就是时刻提醒自己勿忘初心，想想当时是怎样的心境想要坚持，在没有走到最后的最后时说丢掉了最初的那颗心时，请扪心自问是否真的有去坚持过，有去尽力争取过…… 行百里者，应以九十为半，此即末路艰难之谓。改掉初心，而堕入庸俗道者，十有八九，勉励你我，勿忘初心。 那颗最初的心，不应该迫于时间和环境来改变，正视自我的真实感受，时刻警醒自己勿忘初心。 源于散文网 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/Mood-Diary/2017/02/24/勿忘初心.html]]></content>
      <categories>
        <category>Mood Diary</category>
      </categories>
      <tags>
        <tag>Mood Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题汇总3]]></title>
    <url>%2FInterView%2F2017%2F02%2F24%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB3.html</url>
    <content type="text"><![CDATA[HTML面试题1.XHTML和HTML有什么区别 HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言最主要的不同： XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。 2.前端页面有哪三层构成，分别是什么?作用是什么? 结构层 Html 表示层 CSS 行为层 js; 3.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么? Ie(Ie内核) 火狐（Gecko） 谷歌（webkit,Blink） opera(Presto),Safari(wbkit) 4.什么是语义化的HTML? 直观的认识标签 对于搜索引擎的抓取有好处，用正确的标签做正确的事情！ html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 5.HTML5 为什么只需要写 !DOCTYPE HTML？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 6.Doctype作用？标准模式与兼容模式各有什么区别? !DOCTYPE声明位于位于HTML文档中的第一行，处于html 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 7.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websockt, Geolocation移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 对可用性产生负面影响的元素：frame，frameset，noframes；支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式： 8.请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会 sessionStorage和localStorage的存储空间更大； sessionStorage和localStorage有更多丰富易用的接口； sessionStorage和localStorage各自独立的存储空间； 9.如何实现浏览器内多个标签页之间的通信? 调用localstorge、cookies等本地存储方式 CSS面试题1.简要说一下CSS的元素分类 块级元素：div,p,h1,form,ul,li; 行内元素 : span&gt;,a,label,input,img,strong,em; 2.CSS隐藏元素的几种方法（至少说出三种） Opacity:元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互; Visibility:与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏; Display:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在; Position:不会影响布局，能让元素保持可以操作; Clip-path:clip-path 属性还没有在 IE 或者 Edge 下被完全支持。如果要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持度还要低; 3.CSS清楚浮动的几种方法（至少两种） 使用带clear属性的空元素 使用CSS的overflow属性； 使用CSS的:after伪元素； 使用邻接元素处理； 4.CSS居中（包括水平居中和垂直居中） 内联元素居中方案水平居中设置：1.行内元素 设置 text-align:center； 2.Flex布局 设置display:flex;justify-content:center;(灵活运用,支持Chroime，Firefox，IE9+) 垂直居中设置：1.父元素高度确定的单行文本（内联元素） 设置 height = line-height； 2.父元素高度确定的多行文本（内联元素） a:插入 table （插入方法和水平居中一样），然后设置 vertical-align:middle； b:先设置 display:table-cell 再设置 vertical-align:middle； 块级元素居中方案水平居中设置：1.定宽块状元素 设置 左右 margin 值为 auto； 2.不定宽块状元素 a:在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto； b:给该元素设置 displa:inine 方法； c:父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:50%； 垂直居中设置： 使用position:absolute（fixed）,设置left、top、margin-left、margin-top的属性; 利用position:fixed（absolute）属性，margin:auto这个必须不要忘记了; 利用display:table-cell属性使内容垂直居中; 使用css3的新属性transform:translate(x,y)属性; 使用:before元素; 5.写出几种IE6 BUG的解决方法 双边距BUG float引起的 使用display 3像素问题 使用float引起的 使用dislpay:inline -3px 超链接hover 点击后失效 使用正确的书写顺序 link visited hover active Ie z-index问题 给父级添加position:relative Png 透明 使用js代码 改 Min-height 最小高度 ！Important 解决’ select 在ie6下遮盖 使用iframe嵌套 为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px） 6.对于SASS或是Less的了解程度？喜欢那个？ 语法介绍 7.Bootstrap了解程度 特点，排版，插件的使用; 8.页面导入样式时，使用link和@import有什么区别？ link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 9.介绍一下CSS的盒子模型？ 有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading; 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border). 10.CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？ id选择器（ # myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（ * ） 属性选择器（a[rel = “external”]） 伪类选择器（a: hover, li: nth - child） 可继承的样式： font-size font-family color, UL LI DL DD DT; 不可继承的样式：border padding margin width height ; 优先级就近原则，同权重情况下样式定义最近者为准; 优先级为:!important &gt; id &gt; class &gt; tagimportant 比 内联优先级高 11.CSS3有哪些新特性？ CSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜增加了更多的CSS选择器 多背景 rgba JavaScript面试题1.javascript的typeof返回哪些数据类型 Ｏbject number function boolean underfind; 2.例举3种强制类型转换和2种隐式类型转换? 强制（parseInt,parseFloat,number）隐式（== – ===）； 3.数组方法pop() push() unshift() shift() Push()尾部添加 pop()尾部删除 Unshift()头部添加 shift()头部删除 4.ajax请求的时候get 和post方式的区别? 一个在url后面 一个放在虚拟载体里面有大小限制 安全问题应用不同 一个是论坛等只需要请求的，一个是类似修改密码的; 5.call和apply的区别 Object.call(this,obj1,obj2,obj3) Object.apply(this,arguments) 6.ajax请求时，如何解释json数据 使用eval parse,鉴于安全性考虑 使用parse更靠谱; 7.事件委托是什么 让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！ 8.闭包是什么，有什么特性，对页面有什么影响?简要介绍你理解的闭包 闭包就是能够读取其他函数内部变量的函数。 9.添加 删除 替换 插入到某个接点的方法 obj.appendChidl()obj.innersetBeforeobj.replaceChildobj.removeChild 10.说一下什么是javascript的同源策略？ 一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合 11.编写一个b继承a的方法; 1234567891011function A(name)&#123; this.name = name; this.sayHello = function()&#123;alert(this.name+” say Hello!”);&#125;;&#125;function B(name,id)&#123; this.temp = A; this.temp(name); //相当于new A(); delete this.temp; this.id = id; this.checkId = function(ID)&#123;alert(this.id==ID)&#125;;&#125; 12.如何阻止事件冒泡和默认事件 12345678function stopBubble(e)&#123; if (e &amp;&amp; e.stopPropagation) e.stopPropagation() else window.event.cancelBubble=true&#125;return false 13.下面程序执行后弹出什么样的结果? 12345678910111213141516171819function fn() &#123; this.a = 0; this.b = function() &#123; alert(this.a) &#125;&#125;fn.prototype = &#123; b: function() &#123; this.a = 20; alert(this.a); &#125;, c: function() &#123; this.a = 30; alert(this.a); &#125;&#125;var myfn = new fn();myfn.b();myfn.c(); 14.谈谈This对象的理解。 this是js的一个关键字，随着函数使用场合不同，this的值会发生变化。但是有一个总原则，那就是this指的是调用函数的那个对象。this一般情况下：是全局对象Global。 作为方法调用，那么this就是指这个对象 15.下面程序的结果 1234567891011function fun(n,o) &#123; console.log(o) return &#123; fun:function(m)&#123; return fun(m,n); &#125; &#125;;&#125;var a = fun(0); a.fun(1); a.fun(2); a.fun(3);var b = fun(0).fun(1).fun(2).fun(3);var c = fun(0).fun(1); c.fun(2); c.fun(3); //答案：//a: undefined,0,0,0//b: undefined,0,1,2//c: undefined,0,1,1 16.下面程序的输出结果 123456789var name = &apos;World!&apos;;(function () &#123; if (typeof name === &apos;undefined&apos;) &#123; var name = &apos;Jack&apos;; console.log(&apos;Goodbye &apos; + name); &#125; else &#123; console.log(&apos;Hello &apos; + name); &#125;&#125;)(); 17.了解Node么？Node的使用场景都有哪些？ 高并发、聊天、实时消息推送 18.介绍下你最常用的一款框架 jquery,rn,angular等; 19.对于前端自动化构建工具有了解吗？简单介绍一下 Gulp,Grunt等； 20.介绍一下你了解的后端语言以及掌握程度 其它1.对Node的优点和缺点提出了自己的看法？ (优点） 12345&gt; 因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，&gt; 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。&gt; 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，&gt; 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。&gt; &gt; （缺点） 123&gt; Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，&gt; 而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。&gt; 2.你有哪些性能优化的方法？ （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。（2）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4） 当需要设置的样式很多时设置className而不是直接操作style。（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示div+css布局慢。对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。 3.http状态码有那些？分别代表是什么意思？ 100-199 用于指定客户端应相应的某些动作。200-299 用于表示请求成功。300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。400-499 用于指出客户端的错误。400 1、语义有误，当前请求无法被服务器理解。401 当前请求需要用户验证 403 服务器已经理解请求，但是拒绝执行它。500-599 用于支持服务器错误。 503 – 服务不可用 4.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 查找浏览器缓存 DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求 进行HTTP协议会话 客户端发送报头(请求报头) 文档开始下载 文档树建立，根据标记请求所需指定MIME类型的文件 文件显示 浏览器这边做的工作大致分为以下几步： 加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。 解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等） 5.你常用的开发工具是什么，为什么？ Sublime,Atom,Nodepad++; 6.说说最近最流行的一些东西吧？常去哪些网站？ Node.js、MVVM、React-native,Angular,Weex等 CSDN,Segmentfault,博客园,掘金,Stackoverflow等 7.介绍下你的项目（如果有的话）？并说一下在做这个项目中运用的技术以及遇到的难题是如何解决的 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/InterView/2017/02/24/前端面试题汇总3.html]]></content>
      <categories>
        <category>InterView</category>
      </categories>
      <tags>
        <tag>InterView Question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题汇总2]]></title>
    <url>%2FInterView%2F2017%2F02%2F24%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB2.html</url>
    <content type="text"><![CDATA[『HTML&amp;CSS基础』【HTML】 行内元素关注行内置换元素 类似inline-block方式展现 input textarea img select 浏览器内核基于Webkit：Chrome - blink、腾讯X5、UC U3、华为T9基于Gecko：Firefox基于Trident：IE基于Presto：Opera兼备Webkit&amp;Trident：猎豹、360 W3C标准包括结构(xhtml,xml)、表现(css)、行为(ecmascript、dom)的标准。更好地规范浏览器对页面渲染，使得同一套网页方案尽可能在多套浏览器中表现一致。提高开发者开发效率和用户体验 Doctype用来告诉浏览器以什么文档类型解析html，没有的话，会按照向下兼容的怪异模式对文档进行解析h4及以下需要引用dtd声明，dtd有标准型和过渡型两种。两者区别可忽略h5不急于SGML标准，因此不需要引用dtd 标签语义化的重要性1.便于浏览器、搜索引擎解析2.在没css情况也以一种文档形式展现，便于阅读3.有利于SEO4.有利于代码的阅读和维护 strong与em的异同同：都是对文本起强调作用异：em以斜体显示文本，strong更利于SEO识别语义 SEO 详细可分为白帽SEO和黑帽SEOSEO的主要方面：1.网站标题、关键字、描述 (meta)2.网站结构布局优化：目录层级不要太多，尽量让Spider跳转3次就可以到达网站的任意一个内页3.网站代码优化：SEO会过滤掉display none的元素、利用&lt;meta description和&lt;meta keywords&gt;、html语义化 图片格式png-8 256色、png-24、gif、apng(Chrome不支持)、svg、webp(ios不支持) link vs @import区别：1.link无兼容性缺点，@import仅兼容IE5+2.link权重高于import3.link外链的css与html是并行加载的，而import需等html加载完才加载 【CSS】 CSS盒模型包括 margin padding border contentIE盒模型 (lt IE8)：content包含padding和border如何改变：box-sizing CSS可继承属性与font有关的属性 如font-size、font-family、font-weight等line-height、color、text-align、text-indent等 BFC不同的display会参与不同的环境(formatting context)去渲染，而block参与BFCBFC特点1.同个BFC内盒子产生margin塌陷2.计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算3.BFC就是页面上的一个隔离的独立容器，里外互相不影响产生新BFC1.float属性不为none2.position为absolute或fixed3.display为inline-block | table-cell | table-caption | flex | inline-flex4.overflow不为visible 清除浮动1.形成新的BFC2.新增div 设置clear:both3.在父元素添加:after伪类，设置content:&quot;&quot;;display:block;clear:both;zoom:1 positionabsolute | relative | static | sticky | fixed 『HTML5』【新标签】 新增的标签1.布局，内容 &lt;header&gt; &lt;section&gt; &lt;nav&gt; &lt;article&gt; &lt;aside&gt; &lt;mark&gt; &lt;footer&gt;2.表单 &lt;datalist&gt; &lt;keygen&gt; &lt;output&gt;3.媒体 &lt;canvas&gt; &lt;video&gt; &lt;audio&gt; &lt;figure&gt; &lt;figcaption&gt; &lt;source&gt;4.状态 &lt;progress&gt; &lt;meter&gt;5.冷门 &lt;command&gt; &lt;details&gt; &lt;summary&gt; 表单新类型email url number tel search color DatePicker 表单新属性autocomplete autofocus require pattern placeholder multiple 【新API】 交互重力感应 DeviceOrientation手机加速传感器 DeviceMotion history 详细以Pjax方式实现SPA history.pushState history.replaceState 解决ajax不能后退前进问题 储存客户端储存：localStorage sessionStorage&gt;只存在一个会话周期内 跨域postMessage 【Web app】 常见dprip6 2、ip6+ 3、nexus5 3 移动端适配1.自适应方式2.viewport方式3.rem方式4.scale()方式缩放 常用metaIE相关避免IE使用兼容模式 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;为不支持viewport的IE Mobile设定宽度 &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot; /&gt;是否对手持设备友好 &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot; /&gt;UC浏览器强制竖屏 &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot; /&gt;强制全屏 &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot; /&gt;应用模式 &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot; /&gt;X5浏览器强制竖屏 &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot; /&gt;强制全屏 &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;yes&quot; /&gt;应用模式 &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot; /&gt;360开启极速模式 &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt; iphone相关启动webapp功能 删除工具栏和菜单栏 &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;控制状态栏颜色 &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;开启号码或邮箱检测 &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;添加主屏幕icon &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;touch-icon-iphone.png&quot;&gt; 『CSS3』【新属性】flex、column、文本换行、媒体查询、待补充…… 开启GPU加速注意启用-webkit-backface-visibility:hidden; -webkit-perspective:1000;解决启用transform3d页面闪烁和抖动问题 【动画】 CSS3动画性能 『Javascript』【原生】 js数据类型5基本 string number boolean undefined null 储存在栈内存中1复杂 object 储存在堆内存中 this指向this总是指向函数的直接调用者（而非间接调用者） null和undefined区别null表示一个无的对象undefined表示一个无的初始值。表示此处应该有值，但还没有定义，即缺少值 new的具体作用如var p = new P();var p = {}; //创建新对象p.__proto__ = P.prototype; //继承构造函数的原型P.call(p); //修改this指向 创建对象方式对象字面量、工厂模式、构造函数、原型模式、构造函数+原型 原型 原型链每个对象都有一个属性 prototype 当需要从对象中寻找属性时，如果在当前对象上没有找到就会从原型对象开始找 一直追溯到原型链的最顶端 实现继承1.构造函数继承 详细 利用call、apply修改this指向 让子元素原型指向父元素实例，注意要修改子元素prototype.constructor指向 将需继承的属性写在父元素的prototype上，让子元素prototype指向父元素prototype，但在修改子元素prototype.constructor指向时会同时修改父元素prototype.constructor 同上方法 利用中介函数 2.非构造函数继承 详细把父对象的属性，全部拷贝给子对象 浅拷贝vs深拷贝浅拷贝深拷贝 递归调用浅拷贝 闭包 详细用途：读取函数内部变量。变量得不到销毁，一直储存在内存中，可能造成内存泄漏 内存泄漏指分配的内存既不能使用又得不到回收 如为某元素绑定了一个事件，而该元素又从dom中移除 滥用闭包 两变量互相引用 原生Ajax实现过程1.获取XMLHttpRequest对象2.xhr.open(type,url,ifAsyn)3.监听xhr状态改变，xhr.onreadystatechange = function(){} xhr.readyState==4&amp;&amp;xhr.status==200说明请求成功【readyState：0=未初始化 1=启动 2=发送 3=接收 4=完成】4.xhr.send() GET和POST区别GET 安全性低 可传内容少 通过url传值POST 安全性高 可传内容多 通过表单传值 事件处理 详细 事件委托利用事件冒泡机制 将事件绑定在父元素上，节省性能 事件处理程序DOM0 -&gt; DOM1 -&gt; DOM2 (对比与0，可同时绑定多个事件) mouseover和mouseenter区别mouseenter不冒泡 数组去重hash方式和index方式 12345678910111213141516171819Array.prototype.unique = function()&#123;var n = [];for(var i=0,len=this.length;i&lt;len;i++)&#123; if(n.indexOf(this[i])==-1) &#123; n.push(this[i]) &#125;&#125;return n;&#125;Array.prototype.unique2 = function()&#123; var n = &#123;&#125;,a =[]; for(var i=0,len=this.length;i&lt;len;i++)&#123; if(!n[this[i]]) &#123; a.push(this[i]); n[this[i]] = true; &#125; &#125; return a;&#125; ES5数组新方法 斐波纳挈数列高效递归 详细附斐波纳挈数列 123456789function getNthFibonacci(count) &#123; var fibonacci = [1,1]; for(var i=2;i&lt;=count;i++)&#123; fibonacci[i] = fibonacci[i-1]+ fibonacci[i-2]; &#125; return fibonacci[count];&#125;;var a = getNthFibonacci(5);console.log(a) getComputedStyle和style区别getC 只读 可获取未被style定义的样式style 读写 只可获取含style的样式 DOM插入新节点document:createElement()、createDocumentFragment()、createTextNode()insertBefore(new,old)获取节点childNodes、parentNode、previousSibling、nextSibling、firstChild、lastChild、children节点操作appendChild、removeChild、replaceChild、cloneNode、normalize获取位置 浏览器宽高 window.innerWidth document.documentElement.clientWidth 文档宽高 document.documentElement.offsetHeight、 document.documentElement.scrollHeight 到文档的最端处距离 offsetTop、offsetLeft BOM浏览器内核 navigator.appVersion 异步编程方法1.回调函数，这是异步编程最基本的方法。2.事件监听，另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。3.发布/订阅，上一节的”事件”，完全可以理解成”信号”。4.Promises对象，Promises 对象是CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。 【jQuery】 操作DOM ajax 【模块化】【MV*】详细【虚拟DOM】详细以对象树的方式储存在内存中 『性能优化』 雅虎14条 详细 移动端优化 16毫秒的优化 详细 google提出1s完成终端首屏渲染：网络消耗+js执行与页面渲染 浏览器渲染频率1s 60帧，确保每一帧能在16ms内执行与渲染，尽可能避免重排与重绘 使用RAF控制渲染频率，减少重复渲染，避免事件重复执行 让js操作读写分离 渲染路径优化 最小化关键资源数量 最小化关键资源字节 最小化关键路径长度 页面直出 详细 server上获取数据并将数据与页面模板结合，在服务端渲染成最终的 HTML 返回最终的 HTML 展示 『跨域与前端安全』 跨域的方式 JSONP：强行执行不同域下的JS文件，需要外部JS配合。只能用GET方式 CORS：服务器端设置Access-Control-Allow-Origin，使其能被其他域使用AJAX访问到 domain+iframe：只适用主域相同子域不同的两个站。需要将两个站的document.domain设成同一个主域 window.postMessage(msg,targetOrgin) 跨域攻击 详细 跨域脚本 跨域请求伪造 『HTTP 』 HTTP报文 HTTP/1 HTTP/2 HTTPS 详细建立在TCP基础上 状态码 缓存设置缓存 服务器返回Cache-Control:max-age=xxx；expires:Thu, 03 Jan 2019 04:24:16 GMT、设置etag、last-modified 实际上浏览器输入 url 之后敲下回车就是先看本地 cache-control、expires 的情况，刷新(F5)就是忽略先看本地cache-control、expires 的情况，带上条件If-None-Match、If-Modified-Since，强制刷新(Ctrl + F5)就是不带条件的访问。 描述从输入url到一个页面展示在你面前的全部过程 DNS Lookup 建立TCP连接 发送http请求 服务器发送响应 浏览器加载解析DOM&amp;CSS 生成DOM Tree&amp;CSS RuleTree DOMTree和CSS RuleTree结合生成RenderTree 对RenderTree上的每一个元素计算其坐标&gt;称为布局 对RenderTree的元素进行绘制和展示&gt;称为『painting』 引申-当页面渲染时，浏览器发生了什么 『工具』【前端自动化工具】 grunt glup 【CSS预处理】优势： 用嵌套方式写CSS，结构更加的清晰 可使用变量、函数，更类似编程的方式 可将一整套CSS拆分成若干个组件，粒子性、可组合的特点更加明显 sass less compass 『数据结构』 排序 详细不稳定的排序 快速排序、选择排序、希尔排序、堆排序 二叉树原理与实现 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/InterView/2017/02/24/前端面试题汇总2.html]]></content>
      <categories>
        <category>InterView</category>
      </categories>
      <tags>
        <tag>InterView Question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题汇总1]]></title>
    <url>%2FInterView%2F2017%2F02%2F24%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB1.html</url>
    <content type="text"><![CDATA[本文旨在加深对前端知识点的理解，资料来源于网络 一些开放性题目1234567891.自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。2.项目介绍3.如何看待前端开发？4.平时是如何学习前端开发的？5.未来三到五年的规划是怎样的？ position的值， relative和absolute分别是相对于谁进行定位的？ absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。 relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出 如何解决跨域问题 JSONP： 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 12345678910111213141516171819&lt;script&gt; function createJs(sUrl)&#123; var oScript = document.createElement(&apos;script&apos;); oScript.type = &apos;text/javascript&apos;; oScript.src = sUrl; document.getElementsByTagName(&apos;head&apos;)[0].appendChild(oScript); &#125; createJs(&apos;jsonp.js&apos;); box(&#123; &apos;name&apos;: &apos;test&apos; &#125;); function box(json)&#123; alert(json.name); &#125;&lt;/script&gt; CORS 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 通过修改document.domain来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain 使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。 XML和JSON的区别？123456789101112131415(1).数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。(2).数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。(3).数据描述方面。JSON对数据的描述性比XML较差。(4).传输速度方面。JSON的速度要远远快于XML。 谈谈你对webpack的看法WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。 webpack的两大特色： 1231.code splitting（可以自动完成）2.loader 可以处理各种类型的静态文件，并且支持串联操作 webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 webpack具有requireJs和browserify的功能，但仍有很多自己的新特性： 1234567891011121314151. 对 CommonJS 、 AMD 、ES6的语法做了兼容2. 对js、css、图片等资源文件都支持打包3. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持4. 有独立的配置文件webpack.config.js5. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间6. 支持 SourceUrls 和 SourceMaps，易于调试7. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活8.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快 说说TCP传输的三次握手四次挥手策略为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 断开一个TCP连接则需要“四次握手”： 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。 说说你对作用域链的理解作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 创建ajax过程1234567891011(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.(3)设置响应HTTP请求状态变化的函数.(4)发送HTTP请求.(5)获取异步调用返回的数据.(6)使用JavaScript和DOM实现局部刷新. 渐进增强和优雅降级渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 总的来说有以下几点： 123456781.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等。2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 XSS原理及防范 Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。比如：攻击者在论坛中放一个 看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单， 当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS防范方法 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。 其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。 尽量采用POST 而非GET 提交表单 XSS与CSRF有什么区别吗？ XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。 要完成一次CSRF攻击，受害者必须依次完成两个步骤： 123登录受信任网站A，并在本地生成Cookie。在不登出A的情况下，访问危险网站B。 CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 通过验证码的方法 Web Worker 和webSocket worker主线程: 12345671.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。2.通过worker.postMessage( data ) 方法来向worker发送数据。3.绑定worker.onmessage方法来接收worker发送过来的数据。4.可以使用 worker.terminate() 来终止一个worker的执行。 WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个HTML5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。 HTTP和HTTPSHTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。 默认HTTP的端口号为80，HTTPS的端口号为443。 为什么HTTPS安全因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 对前端模块化的认识 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 AMD 是提前执行，CMD 是延迟执行。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 CMD模块方式 12345define(function(require, exports, module) &#123; // 模块代码&#125;); Javascript垃圾回收方法 标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。 你觉得前端工程的价值体现在哪123456789为简化用户使用提供技术支持（交互部分）为多个浏览器兼容性提供支持为提高用户浏览速度（浏览器性能）提供支持为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持为展示数据提供支持（数据接口） 谈谈性能优化问题代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。 请求带宽：压缩文件，开启GZIP， 代码层面的优化 用hash-table来优化查找 少用全局变量 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 用setTimeout来避免页面失去响应 缓存DOM节点查找的结果 避免使用CSS Expression 避免全局查询 避免使用with(with会创建自己的作用域，会增加作用域链长度) 多个变量声明合并 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率 尽量避免写在HTML标签中写Style属性 移动端性能优化 尽量使用css3动画，开启硬件加速。 适当使用touch事件代替click事件。 避免使用css3渐变阴影效果。 可以用transform: translateZ(0)来开启硬件加速。 不滥用Float。Float在渲染时计算量比较大，尽量减少使用 不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。 合理使用requestAnimationFrame动画代替setTimeout CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加 PC端的在移动端同样适用 相关阅读：如何做到一秒渲染一个移动页面 什么是Etag？当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。 情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。 情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag 然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化 情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。 情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同① ① 只有get请求会被缓存，post请求不会 Expires和Cache-ControlExpires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。 123456789Cache-Control: no-cache, private, max-age=0ETag: abcdeExpires: Thu, 15 Apr 2014 20:00:00 GMTPragma: privateLast-Modified: $now // RFC1123 format ETag应用:Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match。请求一个文件的流程可能如下： ====第一次请求=== 1231.客户端发起 HTTP GET 请求一个文件；2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如&quot;2e681a-6-5d044840&quot;)(假设服务器支持Etag生成和已经开启了Etag).状态码200 ====第二次请求=== 1客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办 答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后， 服务器才能返回304.(不要陷入到底使用谁的问题怪圈) 为什么使用Etag请求头? Etag 主要为了解决 Last-Modified 无法解决的一些问题。 栈和队列的区别?12345栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。队列先进先出，栈先进后出。栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 栈和堆的区别？1234567栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。堆（数据结构）：堆可以被看成是一棵树，如：堆排序；栈（数据结构）：一种先进后出的数据结构。 快速 排序的思想并实现一个快排？“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较 12345678910111213141516171819202122232425262728&lt;script type=&quot;text/javascript&quot;&gt; function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr;//如果数组只有一个数，就直接返回； &#125; var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]);//基准点的左边的数传到左边数组 &#125; else&#123; right.push(arr[i]);//基准点的右边的数传到右边数组 &#125; &#125; return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较 &#125; alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87”&lt;/script&gt; 你觉得jQuery或zepto源码有哪些写的好的地方(答案仅供参考) jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。 12345678910111213(function( window, undefined ) &#123; //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery;&#125;)( window ); jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。 ES6的了解新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念 js继承方式及其优缺点 原型链继承的缺点 1一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承） 1借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承 1组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 具体请看：JavaScript继承方式详解 关于Http 2.0 你知道多少？HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 defer和async defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 谈谈浮动和清除浮动浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。 如何评价AngularJS和BackboneJSbackbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or Zepto) 就比一个AngularJS 多出了2 次HTTP请求. Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新。 AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。 用过哪些设计模式？ 工厂模式： 123主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。 12345678910function createObject(name,age,profession)&#123;//集中实例化的函数var obj = new Object(); obj.name = name; obj.age = age; obj.profession = profession; obj.move = function () &#123; return this.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession; &#125;; return obj;&#125;var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 = createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例 构造函数模式 使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于： 123451.构造函数方法没有显示的创建对象 (new Object());2.直接将属性和方法赋值给 this 对象;3.没有 renturn 语句。 说说你对闭包的理解使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被垃圾回收机制回收 具体请看：详解js闭包 请你谈谈Cookie的弊端cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。 第一：每个特定的域名下最多生成20个cookie 12345671.IE6或更低版本最多20个cookie2.IE7和之后的版本最后可以有50个cookie。3.Firefox最多50个cookie4.chrome和Safari没有做硬性限制 IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。 cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。 IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。 优点：极高的扩展性和可用性 12345671.通过良好的编程，控制保存在cookie中的session对象的大小。2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。 缺点： 11.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉. 1232.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 浏览器本地存储在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。 html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 cookie 和session 的区别：12345678910111213141516171、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 display:none和visibility:hidden的区别？ 123display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 CSS中 link 和@import 的区别是？ 1234567(1) link属于HTML标签，而@import是CSS提供的;(2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;(4) link方式的样式的权重 高于@import的权重. position:absolute和float属性的异同 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 不同点：float仍会占据位置，absolute会覆盖文档流中的其他元素。 介绍一下box-sizing属性？ box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。 content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高 border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content 标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？ 12345678910111213141516171.id选择器（ # myid）2.类选择器（.myclassname）3.标签选择器（div, h1, p）4.相邻选择器（h1 + p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（ * ）8.属性选择器（a[rel = &quot;external&quot;]）9.伪类选择器（a: hover, li:nth-child） 优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高,但内联比 id 要高 CSS3新增伪类举例： 12345678910111213p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:enabled :disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中。 CSS3有哪些新特性？ 12345678910111213CSS3实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜增加了更多的CSS选择器 多背景 rgba在CSS3中唯一引入的伪元素是::selection.媒体查询，多栏布局border-image CSS3中新增了一种盒模型计算方式：box-sizing。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下： content-box（默认）布局所占宽度Width： 1Width = width + padding-left + padding-right + border-left + border-right 布局所占高度Height: 1Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box布局所占宽度Width： 1Width = width(包含padding-left + padding-right) + border-top + border-bottom 布局所占高度Height: 1Height = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box布局所占宽度Width： 1Width = width(包含padding-left + padding-right + border-left + border-right) 布局所占高度Height: 1Height = height(包含padding-top + padding-bottom + border-top + border-bottom) 对BFC规范的理解？ 123 BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。 说说你对语义化的理解？12345671，去掉或者丢失样式的时候能够让页面呈现出清晰的结构2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器以何种模式来渲染文档。 2）、严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 你知道多少种Doctype文档类型？123456789 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 HTML与XHTML——二者有什么区别1234567891011121314151617区别：1.所有的标记都必须要有一个相应的结束标记2.所有标签的元素和属性的名字都必须使用小写3.所有的XML标记都必须合理嵌套4.所有的属性必须用引号&quot;&quot;括起来5.把所有&lt;和&amp;特殊符号用编码表示6.给所有属性赋一个值7.不要在注释内容中使“--”8.图片必须有说明文字 常见兼容性问题？1234567891011121314png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一。IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）#box&#123; float:left; width:10px; margin:0 0 0 100px;&#125;这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)渐进识别的方式，从总体中逐渐排除局部。 1234567891011121314151617首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。css .bb&#123; background-color:#f1ee18;/*所有识别*/ .background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ &#125; 123怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用[html5](http://www.w3.org/TR/html5/single-page.html)推荐的写法：`&lt;doctype html&gt;` 上下margin重合问题 123ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。 解释下浮动和它的工作原理？清除浮动的技巧1浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 12345678910111.使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。2.使用overflow。 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。3.使用after伪对象清除浮动。 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； 浮动元素引起的问题和解决办法？1234567浮动元素引起的问题：（1）父元素的高度无法被撑开，影响与父元素同级的元素（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式： 123.clearfix:after&#123;content: &quot;.&quot;;display: block;height: 0;clear: both;visibility: hidden;&#125;.clearfix&#123;display: inline-block;&#125; /* for IE/Mac */ 清除浮动的几种方法： 1234567891011121314151617181920211，额外标签法，&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）2，使用after伪类#parent:after&#123; content:&quot;.&quot;; height:0; visibility:hidden; display:block; clear:both; &#125;3,浮动外部元素4,设置overflow为hidden或者auto DOM操作——怎样添加、移除、移动、复制、创建和查找节点。 1）创建新节点 12345createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 1234567appendChild()removeChild()replaceChild()insertBefore() //并没有insertAfter() 3）查找 123456getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？123456789101112131415HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。拖拽释放(Drag and drop) API语义化更好的内容标签（header,nav,footer,aside,article,section）音频、视频API(audio,video)画布(Canvas) API地理(Geolocation) API本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除 123表单控件，calendar、date、time、email、url、search新的技术webworker, websocket, Geolocation 移除的元素 123纯表现的元素：basefont，big，center，font, s，strike，tt，u；对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： 1234567891011121314IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt;如何区分： DOCTYPE声明\新增的结构元素\功能元素 如何实现浏览器内多个标签页之间的通信?1调用localstorge、cookies等本地存储方式 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？1234567 FOUC - Flash Of Unstyled Content 文档样式闪烁 &lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt;而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。 解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。 null和undefined的区别？null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： 1（1）变量被声明了，但没有赋值时，就等于undefined。 1（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 1（3）对象没有赋值的属性，该属性的值为undefined。 1（4）函数没有返回值时，默认返回undefined。 null表示”没有对象”，即该处不应该有值。典型用法是： 123（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 new操作符具体干了什么呢?123451、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2、属性和方法被加入到 this 引用的对象中。3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 12345var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); js延迟加载的方式有哪些？1defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js call() 和 apply() 的区别和作用？作用：动态改变某个类的某个方法的运行环境（执行上下文）。 区别参见：JavaScript学习总结（四）function函数部分 哪些操作会造成内存泄漏？123内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 123setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 详见：详解js变量、作用域及内存 列举IE 与其他浏览器不一样的特性？ IE支持currentStyle，FIrefox使用getComputStyle IE 使用innerText，Firefox使用textContent 滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num 事件方面：IE：attachEvent：火狐是addEventListener 鼠标位置：IE是event.clientX；火狐是event.pageX IE使用event.srcElement；Firefox使用event.target IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list-style:none CSS圆角：ie7以下不支持圆角 WEB应用从服务器主动推送Data到客户端有那些方式？Javascript数据推送 Commet：基于HTTP长连接的服务器推送技术 基于WebSocket的推送方案 SSE（Server-Send Event）：服务器推送数据新方式 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？1234567前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 1前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 123456789参与项目，快速高质量完成实现效果图，精确到1px；与团队成员，UI设计，产品经理的沟通；做好的页面结构，页面重构和用户体验；处理hack，兼容、写出优美的代码格式；针对服务器的优化、拥抱最新前端技术。 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？123456789分为4个步骤：（1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。（2）， 浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。（3），一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。（4），此时，`Web`服务器提供资源服务，客户端开始下载资源。 123请求返回后，便进入了我们关注的前端模块简单来说，浏览器会解析`HTML`生成`DOM Tree`，其次会根据CSS生成CSS Rule Tree，而`javascript`又可以根据`DOM API`操作`DOM` 详情：从输入 URL 到浏览器接收的过程中发生了什么事情？ javascript对象的几种创建方式123456789101112131，工厂模式2，构造函数模式3，原型模式4，混合构造函数和原型模式5，动态原型模式6，寄生构造函数模式7，稳妥构造函数模式 javascript继承的6种方法12345678910111，原型链继承2，借用构造函数继承3，组合继承(原型+借用构造)4，原型式继承5，寄生式继承6，寄生组合式继承 详情：JavaScript继承方式详解 创建ajax的过程12345678910111213141516171819202122232425(1)创建`XMLHttpRequest`对象,也就是创建一个异步调用对象.(2)创建一个新的`HTTP`请求,并指定该`HTTP`请求的方法、`URL`及验证信息.(3)设置响应`HTTP`请求状态变化的函数.(4)发送`HTTP`请求.(5)获取异步调用返回的数据.(6)使用JavaScript和DOM实现局部刷新.var xmlHttp = new XMLHttpRequest();xmlHttp.open(&apos;GET&apos;,&apos;demo.php&apos;,&apos;true&apos;);xmlHttp.send()xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState === 4 &amp; xmlHttp.status === 200)&#123; &#125;&#125; 详情：JavaScript学习总结（七）Ajax和Http状态字 异步加载和延迟加载1234567891.异步加载的方案： 动态插入script标签2.通过ajax去获取js代码，然后通过eval执行3.script标签上添加defer或者async属性4.创建并插入iframe，让它异步执行js5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。 ie各版本和chrome可以并行下载多少个资源12IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个Firefox，chrome也是6个 Flash、Ajax各自的优缺点，在使用中如何取舍？ Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。 Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM 请解释一下 JavaScript 的同源策略。概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 为什么要有同源限制？我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点： 现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 GET和POST的区别，何时使用POST？123GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 123GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 1234567然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？123451. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；3. `ev.stopPropagation()`;注意旧ie的方法 `ev.cancelBubble = true`; ajax的缺点和在IE下的问题？详情请见：JavaScript学习总结（七）Ajax和Http状态字 ajax的缺点 1234567891、ajax不支持浏览器back按钮。2、安全问题 AJAX暴露了与服务器交互的细节。3、对搜索引擎的支持比较弱。4、破坏了程序的异常机制。5、不容易调试。 IE缓存问题 在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(&#39;t&#39;= + new Date().getTime()) 或者： 1open(&apos;GET&apos;,&apos;demo.php?rand=+Math.random()&apos;,true);// Ajax请求的页面历史记录状态问题 可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时页面状态的变化。 还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变 谈谈你对重构的理解网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 1234567891011对于传统的网站来说重构通常是：表格(table)布局改为DIV+CSS使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)对于移动平台的优化针对于SEO进行优化深层次的网站重构应该考虑的方面 12345678910111213减少代码间的耦合让代码保持弹性严格按规范编写代码设计可扩展的API代替旧有的框架、语言(如VB)增强用户体验通常来说对于速度的优化也包含在重构中 123456789压缩JS、CSS、image等前端资源(通常是由服务器来解决)程序的性能优化(如数据读写)采用CDN来加速资源加载对于JS DOM的优化HTTP服务器的文件缓存 HTTP状态码12345678910111213141516171819202122232425262728100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 说说你对Promise的理解依照 Promise/A+ 的定义，Promise 有四种状态： 1234567pending: 初始状态, 非 fulfilled 或 rejected.fulfilled: 成功的操作.rejected: 失败的操作.settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled。 Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。 Promise 的构造函数 构造一个 Promise，最基本的用法如下： 123456789101112var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125;&#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下： 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject。 说说你对前端架构师的理解负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护；带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制123456789101112Object.prototype.clone = function()&#123; var o = this.constructor === Array ? [] : &#123;&#125;; for(var e in this)&#123; o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e]; &#125; return o;&#125; 说说严格模式的限制严格模式主要有以下限制： 1234567891011121314151617181920212223242526272829变量必须声明后再使用函数的参数不能有同名属性，否则报错不能使用with语句不能对只读属性赋值，否则报错不能使用前缀0表示八进制数，否则报错不能删除不可删除的属性，否则报错不能删除变量delete prop，会报错，只能删除属性delete global[prop]eval不会在它的外层作用域引入变量eval和arguments不能被重新赋值arguments不会自动反映函数参数的变化不能使用arguments.callee不能使用arguments.caller禁止this指向全局对象不能使用fn.caller和fn.arguments获取函数调用的堆栈增加了保留字（比如protected、static和interface） 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 注：经过测试IE6,7,8,9均不支持严格模式。 如何删除一个cookie 1.将时间设为当前时间往前一点。 123var date = new Date();date.setDate(date.getDate() - 1);//真正的删除 setDate() 方法用于设置一个月的某一天。 2.expires的设置 1document.cookie = &apos;user=&apos;+ encodeURIComponent(&apos;name&apos;) + &apos;;expires = &apos; + new Date(0) &lt;strong&gt;，&lt;em&gt;和&lt;b&gt;，&lt;i&gt;标签1234567&lt;strong&gt; 标签和 &lt;em&gt; 标签一样，用于强调文本，但它强调的程度更强一些。em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 &lt;i&gt;...&lt;/i&gt;;&lt; b &gt; &lt; i &gt;是视觉要素，分别表示无意义的加粗，无意义的斜体。em 和 strong 是表达要素(phrase elements)。 说说你对AMD和Commonjs的理解CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 详情：也谈webpack及其开发模式 document.write()的用法document.write()方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。 document.write只能重绘整个页面。innerHTML可以重绘页面的一部分 编写一个方法 求一个字符串的字节长度假设：一个英文字符占用一个字节，一个中文字符占用两个字节 1234567891011121314151617 function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes(&quot;你好,as&quot;)); git fetch和git pull的区别123git pull：相当于是从远程获取最新版本并merge到本地git fetch：相当于是从远程获取最新版本到本地，不会自动merge 说说你对MVC和MVVM的理解 MVC 12345View 传送指令到 ControllerController 完成业务逻辑后，要求 Model 改变状态Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的。 Angular它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。 1234567组成部分Model、View、ViewModelView：UI界面ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；Model：数据访问层 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 attribute和property的区别是什么？attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 所以： 对于html的标准属性来说，attribute和property是同步的，是会自动更新的， 但是对于自定义的属性来说，他们是不同步的， 说说网络分层里七层模型是哪七层 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP和UDP） 网络层（IP） 物理和数据链路层（以太网） 每一层的作用如下： 12345678物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame）网络层：负责数据包从源到宿的传递和网际互连（包PackeT）传输层：提供端到端的可靠报文传递和错误恢复（段Segment）会话层：建立、管理和终止会话（会话协议数据单元SPDU）表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 各种协议 ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 说说mongoDB和MySQL的区别MySQL是传统的关系型数据库，MongoDB则是非关系型数据库 mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。 对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有：①弱一致性（最终一致），更能保证用户的访问速度：②文档结构的存储方式，能够更便捷的获取数据。 讲讲304缓存的原理服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。 什么样的前端代码是好的高复用低耦合，这样文件小，好维护，而且好扩展。 代码题 css代码题 js代码题 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/InterView/2017/02/24/前端面试题汇总1.html]]></content>
      <categories>
        <category>InterView</category>
      </categories>
      <tags>
        <tag>InterView Question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端资源汇集]]></title>
    <url>%2FResources%2F2017%2F02%2F24%2F%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%B1%87%E9%9B%86.html</url>
    <content type="text"><![CDATA[- 感谢本文原作者，本就有收藏&amp;分享欲，这种事儿早期也想做了，勘叹见识未广而深；幸遇这良心收集，得以借他人之酒杯，一浇我心之夙愿块垒。毕竟人为收集，并未臻于不可附加之境，还是有许多可以补充的点；因此，有特引于博客，将酌情适当**增**删些内容，一来做自己查纠探索之源，二来分享给更多朋友；好文章好工具，很多时候都**被**隐藏于犄角旮旯了，有居干货，欢请分享。 原文链接：http://www.jeffjade.com/2016/03/30/104-front-end-tutorial/ 文章目录 文章目录 1 · 综合类 2 · 入门类 3 · 工具类 4 · 综合效果搜索平台 5 · 团队Blog 6 · 开发中心 7 · Nodejs 8 · 综合API 9 · Ecmascript 10 · Vue 11 · Angularjs 12 · React 13 · Js template 14 · HTML5(HTML)) 15 · CSS3(CSS)) 16 · 移动端API 17 · jQuery 18 · D3 19 · Requriejs 20 · Seajs 21 · Less,sass 22 · Markdown 23 · 兼容性 24 · UI相关 25 · 其它API 26 · 图表类 27 · 正则 28 · 前端规范 29 · PHP 30 · 各大公司开源项目 31 · 常用 32 · 算法 33 · 移动端 34 · JSON 35 · 焦点图 36 · Ext, EasyUI, J-UI 及其它各种UI方案 37 · 页面 社会化 分享功能 38 · 富文本编辑器 39 · 前端概述 40 · Gulp 41 · Grunt 42 · Fis 43 · pc图轮 44 · 移动端图轮 45 · 文件上传 46 · 模拟select 47 · 取色插件 48 · 城市联动 49 · 剪贴板 50 · 简繁转换 51 · 表格 Grid 52 · 在线演示 53 · 常规优化 54 · 优化工具 55 · 在线工具 56 · 前端架构 57 · 推荐作品 58 · 简历模板 59 · 面试题 60 · iconfont 61 · Fiddler 62 · Chrome 63 · Firebug 64 · 移动,微信调试 65 · iOS Simulator 66 · Image 67 · 浏览器同步 68 · 在线PPT制作 69 · 前端导航网站 70 · 常用CDN 71 · Git 72 · 各种日期日历 73 · Date library 74 · 其它 75 · 效果类 76 · 弹出层 77 · 优秀JavaScript项目 综合类 综合类 地址 前端知识体系 http://www.cnblogs.com/sb19871023/p/3894452.html 前端知识结构 https://github.com/JacksonTian/fks Web前端开发大系概览 https://github.com/unruledboy/WebFrontEndStack Web前端开发大系概览-中文版 http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html Web Front-end Stack v2.2 Web Front-end Stack v2.2 免费的编程中文书籍索引 https://github.com/justjavac/free-programming-books-zh_CN 前端书籍 https://github.com/dypsilon/frontend-dev-bookmarks 前端免费书籍大全 https://github.com/vhf/free-programming-books 前端知识体系 http://www.cnblogs.com/sb19871023/p/3894452.html 免费的编程中文书籍索引 https://github.com/justjavac/free-programming-books-zh_CN 智能社 - 精通JavaScript开发 http://study.163.com/course/introduction/224014.htm 重新介绍 JavaScript（JS 教程） https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript 麻省理工学院公开课：计算机科学及编程导论 http://v.163.com/special/opencourse/bianchengdaolun.html JavaScript中的this陷阱的最全收集–没有之一 http://segmentfault.com/a/1190000002640298 JS函数式编程指南 https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html JavaScript Promise迷你书（中文版） http://liubin.github.io/promises-book 腾讯移动Web前端知识库 https://github.com/AlloyTeam/Mars Front-End-Develop-Guide 前端开发指南 https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide 前端开发笔记本 https://li-xinyang.gitbooks.io/frontend-notebook/content 大前端工具集 - 聂微东 https://github.com/nieweidong/fetool 前端开发者手册 https://dwqs.gitbooks.io/frontenddevhandbook/content 入门类 入门类 地址 前端入门教程 http://www.cnblogs.com/jikey/p/3613082.html 瘳雪峰的Javascript教程 http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000 前端工程师必备的PS技能——切图篇 http://www.imooc.com/view/506 结合个人经历总结的前端入门方法 https://github.com/qiu-deqing/FE-learning 工具类 工具类 地址 前端人的俱乐部 http://f2er.club/ 真可以解放你的收藏夹 如何优雅地使用Sublime Text http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/# 新编码神器Atom使用纪要 http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/ css sprite 雪碧图制作 http://www.imooc.com/learn/93 版本控制入门 – 搬进 Github http://www.imooc.com/learn/390 Grunt-beginner前端自动化工具 http://www.imooc.com/learn/30 IntelliJ IDEA 简体中文专题教程 https://github.com/judasn/IntelliJ-IDEA-Tutorial SublimeText https://github.com/jikeytang/sublime-text Atom https://atom.io visual studio code https://code.visualstudio.com 综合效果搜索平台 综合效果搜索平台 地址 JavaScript 资源大全中文版 https://github.com/jobbole/awesome-javascript-cn 100+ 超全的web开发工具和资源 https://xituqu.com/170.html 设计师网址导航 http://hao.uisdc.com/ 快搜 http://so.chongbuluo.com/ 阿里iconfont http://www.iconfont.cn/ zoommyapp.com http://zoommyapp.com/ 高质量图库 unsplash.com https://unsplash.com/ 高质量图库 www.pinterest.com https://www.pinterest.com/ 图库 New Old Stock http://nos.twnsnd.co 复古风图库 500px.com https://500px.com/ 唯美照片 效果网 http://www.jq22.com 花瓣网 http://huaban.com/ 优美图 http://www.topit.me/ codepen http://codepen.io/ 摄图网 http://699pic.com/ 常用的JavaScript代码片段 http://microjs.com 团队Blog 团队Blog-Name 地址 腾讯ISUX http://isux.tencent.com 奇舞周刊 http://old.75team.com/weekly/ 淘宝前端团队（FED） http://taobaofed.org 码农周刊 http://weekly.manong.io WEB前端开发 http://www.css88.com A JS tip per day! http://www.jstips.co 腾讯全端 AlloyTeam http://www.alloyteam.com/webdevelop/ 阿里巴巴-U一点 http://www.aliued.cn 百度WEB前端研发部 http://fex.baidu.com 携程设计委员会 http://ued.ctrip.com/blog/ 平安科技移动开发二队技术周报 https://github.com/PaicHyperionDev/MobileDevWeekly 开发中心 开发中心 地址 mozilla js参考 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript chrome开发中心（chrome的内核已转向blink） https://developer.chrome.com/extensions/api_index.html safari开发中心 https://developer.apple.com/library/safari/navigation microsoft js参考 https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94.aspx js秘密花园 http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html js秘密花园 http://bonsaiden.github.io/JavaScript-Garden/zh w3help http://www.w3help.org 综合Bug集合网站 Nodejs Nodejs 地址 Node.js 包教不包会 https://github.com/alsotang/node-lessons 一个nodejs博客 http://60sky.com 【NodeJS 学习笔记04】新闻发布系统 http://www.cnblogs.com/yexiaochai/p/3536547.html 过年7天乐，学nodejs 也快乐 http://www.cnblogs.com/qqloving/p/3541099.html 七天学会NodeJS https://github.com/nqdeng/7-days-nodejs Nodejs学习笔记（二）— 事件模块 http://www.cnblogs.com/zhongweiv/p/nodejs_events.html nodejs入门 http://www.cnblogs.com/liusuqi/p/3735491.html angularjs nodejs https://github.com/zensh/jsgen 从零开始nodejs系列文章 http://blog.fens.me/series-nodejs 理解nodejs http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb nodejs事件轮询 http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop node入门 http://www.nodebeginner.org/index-zh-cn.html nodejs cms http://ourjs.com/detail/53e1f281c5910a9806000001 Node初学者入门，一本全面的NodeJS教程 http://ourjs.com/detail/529ca5950cb6498814000005 NodeJS的代码调试和性能调优 http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line 综合API 综合API 地址 OverAPI.com http://overapi.com/ javascripting http://www.javascripting.com 各种流行库搜索 http://microjs.com runoob.com-包含各种API集合 http://www.runoob.com 开源中国在线API文档合集 http://tool.oschina.net/apidocs devdocs http://devdocs.io 英文综合API网站 Ecmascript Ecmascript 地址 Understanding ECMAScript 6 - Nicholas C. Zakas https://leanpub.com/understandinges6/read exploring-es6 https://leanpub.com/exploring-es6/read exploring-es6翻译 https://github.com/es6-org/exploring-es6 exploring-es6翻译后预览 http://es6-org.github.io/exploring-es6 阮一峰 es6 http://es6.ruanyifeng.com 阮一峰 Javascript http://javascript.ruanyifeng.com ECMA-262，第 5 版 http://yanhaijing.com/es5 es5 http://es5.github.io Vue Vue.js 地址 Vue2.0 https://vuefe.cn/ Vue http://cn.vuejs.org Vue Router https://router.vuejs.org/ Vuex https://vuex.vuejs.org/ Vue-Cli https://github.com/vuejs/vue-cli Vue 论坛 http://forum.vuejs.org Vue 聊天室 https://gitter.im/vuejs/vue Vue 入门指南 http://www.cnblogs.com/aaronjs/p/3660102.html Vue 的一些资源索引 http://segmentfault.com/a/1190000000411057 awesome-vue https://github.com/vuejs/awesome-vue vue-syntax-highlight https://github.com/vuejs/vue-syntax-highlight Angularjs Angularjs 地址 Angular.js 的一些学习资源 https://github.com/dolymood/AngularLearning angularjs中文社区 http://angularjs.cn Angularjs源码学习 http://www.cnblogs.com/xuwenmin888/p/3739096.html Angularjs源码学习 http://www.ifeenan.com/?c=AngularJS angular对bootstrap的封装 http://angular-ui.github.io/bootstrap angularjs + nodejs https://cnodejs.org/topic/51404e0f069911196d2e3923 吕大豹 Angularjs http://www.cnblogs.com/lvdabao/tag/AngularJs AngularJS 最佳实践 http://www.infoq.com/cn/news/2013/02/angular-web-app Angular的一些扩展指令 http://www.lovelucy.info/angularjs-best-practices.html Angular数据绑定原理 https://github.com/Pasvaz/bindonce 一些扩展Angular UI组件 https://github.com/angular-ui Ember和AngularJS的性能测试 http://voidcanvas.com/emberjs-vs-angularjs-performance-testing 带你走近AngularJS - 基本功能介绍 http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html Angularjs开发指南 http://angular.duapp.com/docs/guide Angularjs学习 http://www.cnblogs.com/amosli/p/3710648.html 不要带着jQuery的思维去学习AngularJS http://www.rainweb.cn/article/angularjs-jquery.html angularjs 学习笔记 http://wangjiatao.diandian.com/?tag=angularjs angularjs 开发指南 http://www.angularjs.cn/T008 angularjs 英文资料 https://github.com/jmcunningham/AngularJS-Learning angular bootstrap http://angular-ui.github.io/bootstrap angular jq mobile https://github.com/opitzconsulting/jquery-mobile-angular-adapter angular ui http://mgcrea.github.io/angular-strap 整合jQuery Mobile+AngularJS经验谈 http://www.tuicool.com/articles/7ZZVr2 有jQuery背景，该如何用AngularJS编程思想 http://blog.jobbole.com/46589/ AngularJS在线教程 http://each.sinaapp.com/angular angular学习笔记 http://www.zouyesheng.com/angular.html React React 地址 react.js 中文论坛 http://www.react-china.org react.js 官方网址 https://facebook.github.io/react/index.html react.js 官方文档 https://facebook.github.io/react/docs/getting-started.html react.js material UI http://material-ui.com/# react.js TouchstoneJS UI http://touchstonejs.io react.js amazeui UI http://amazeui.org/react React 入门实例教程 - 阮一峰 http://www.ruanyifeng.com/blog/2015/03/react.html React Native 中文版 http://wiki.jikexueyuan.com/project/react-native Webpack 和 React 小书 - 前端乱炖 http://www.html-js.com/article/Fakefish%203053 Webpack 和 React 小书 - gitbook https://fakefish.github.io/react-webpack-cookbook webpack https://github.com/webpack/webpack Webpack，101入门体验 http://html-js.com/article/3009 webpack入门教程 http://html-js.com/article/3113 基于webpack搭建前端工程解决方案探索 http://segmentfault.com/a/1190000003499526 Js template Js template 地址 template-chooser http://garann.github.io/template-chooser artTemplate https://github.com/aui/artTemplate tomdjs https://github.com/aui/tmodjs/blob/master/README.md 淘宝模板juicer模板 http://juicer.name/docs/docs_zh_cn.html Fxtpl v1.0 繁星前端模板引擎 http://koen301.github.io/fxtpl laytpl http://laytpl.layui.com mozilla - nunjucks https://github.com/mozilla/nunjucks Juicer https://github.com/PaulGuo/Juicer dustjs http://akdubya.github.io/dustjs etpl http://ecomfe.github.io/etpl HTML5(HTML) HTML(HTML5) 地址 深入理解HTML5标签 https://segmentfault.com/a/1190000002695791 如何写出高效率的HTML https://segmentfault.com/a/1190000002680822 HTML meta标签总结与属性使用介绍 https://segmentfault.com/a/1190000004279791 戏说HTML5 http://www.cnblogs.com/dojo-lzz/p/5059316.html CSS3(CSS) CSS 地址 CSS 语法参考 http://tympanus.net/codrops/css_reference 如何编写可维护的CSS https://github.com/chadluo/CSS-Guidelines/blob/master/README.md CSS3动画手册 http://isux.tencent.com/css3/index.html 腾讯css3动画制作工具 http://isux.tencent.com/css3/tools.html 志爷css小工具集合 http://linxz.github.io/tianyizone css3 js 移动大杂烩 http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb bouncejs 触摸库 http://bouncejs.com animate.css http://daneden.github.io/animate.css 全局CSS的终结(狗带 [译] http://www.alloyteam.com/2015/10/8536 browserhacks http://browserhacks.com 移动端API 移动端API 地址 99移动端知识集合 https://github.com/jtyjty99999/mobileTech 移动端前端开发知识库 https://github.com/AlloyTeam/Mars 移动前端的一些坑和解决方法（外观表现） http://caibaojian.com/mobile-web-bug.html 【原】移动web资源整理 http://www.cnblogs.com/PeunZhang/p/3407453.html zepto 1.0 中文手册 http://mweb.baidu.com/zeptoapi zepto 1.0 中文手册 http://www.html-5.cn/Manual/Zepto zepto 1.1.2 http://www.css88.com/doc/zeptojs_api zepto 中文注释 http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html jqmobile 手册 http://app-framework-software.intel.com/api.php 移动浏览器开发集合 https://github.com/maxzhang/maxzhang.github.com/issues 移动开发大杂烩 https://github.com/hoosin/mobile-web-favorites jQuery jQuery 地址 YOU MIGHT NOT NEED JQUERY http://youmightnotneedjquery.com/ jQuery API 中文文档 http://www.jquery123.com hemin 在线版 http://hemin.cn/jq css88 jq api http://www.css88.com/jqapi-1.9/on css88 jqui api http://www.css88.com/jquery-ui-api 学习jquery http://learn.jquery.com jquery 源码查找 http://james.padolsey.com/jquery Web前端资源汇总(jQuery,Js,Css3等) http://www.cnblogs.com/jihua/p/webfront.html D3 D3 地址 d3 Tutorials https://github.com/mbostock/d3/wiki/Tutorials Gallery https://github.com/mbostock/d3/wiki/Gallery lofter http://datavisual.lofter.com/post/40cf3a_188e535 iteye http://alanland.iteye.com/blog/1878595 ruanyifeng http://javascript.ruanyifeng.com/library/d3.html Requriejs Requriejs 地址 Javascript模块化编程（一）：模块的写法 http://www.ruanyifeng.com/blog/2012/10/javascript_module.html Javascript模块化编程（二）：AMD规范 http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html Javascript模块化编程（三）：require.js的用法 http://www.ruanyifeng.com/blog/2012/11/require_js.html RequireJS入门（一） http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html RequireJS入门（二） http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html RequireJS进阶（三） http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html requrie源码学习 http://www.cnblogs.com/yexiaochai/p/3632580.html requrie 入门指南 http://www.oschina.net/translate/getting-started-with-the-requirejs-library requrieJS 学习笔记 http://www.cnblogs.com/yexiaochai/p/3214926.html requriejs 其一 http://cyj.me/why-seajs/requirejs/ require backbone结合 http://www.cnblogs.com/yexiaochai/p/3221081.html Seajs Seajs 地址 seajs http://seajs.org seajs 中文手册 http://cyj.me/why-seajs/zh Less,sass Less,sass 地址 sass http://www.w3cplus.com/sassguide sass教程-sass中国 http://www.sass.hk Sass 中文文档 http://sass.bootcss.com less http://less.bootcss.com Markdown Markdown 地址 Markdown 语法说明 (简体中文版 http://wowubuntu.com/markdown markdown入门参考 https://github.com/LearnShare/Learning-Markdown/blob/master/README.md gitbook https://www.gitbook.com 国外的在线markdown可编辑成书 mdeditor https://www.zybuluo.com/mdeditor 一款国内的在线markdown编辑器 stackedit https://stackedit.io 国外的在线markdown编辑器，功能强大，同步云盘 mditor http://bh-lay.github.io/mditor 一款轻量级的markdown编辑器 lepture-editor https://github.com/lepture/editor markdown-editor https://github.com/jbt/markdown-editor 作业部落 https://www.zybuluo.com 功能强大，速度流畅，全平台同步 兼容性 兼容性 地址 esma 兼容列表 http://kangax.github.io/compat-table/es6 W3C CSS验证服务 http://jigsaw.w3.org/css-validator/validator.html.zh-cn caniuse http://caniuse.com/#index csscreator http://csscreator.com/properties microsoft https://msdn.microsoft.com/zh-cn/library/cc351024(v=vs.85.aspx 在线测兼容-移动端 http://www.responsinator.com emulators https://www.manymo.com/emulators UI相关 UI相关 地址 Foundation http://foundation.zurb.com/?form=jeffjade.com Bootcss http://v3.bootcss.com/?form=jeffjade.com Element UI http://element.eleme.io/#/zh-CN 基于Vue ANT DESIGN http://ant.design 一个 UI 设计语言 Smart UI http://smartui.chinamzz.com MetroUICSS http://www.w3cplus.com/MetroUICSS Semantic http://semantic-ui.com Layui http://www.layui.com/?form=jeffjade.com Buttons http://alexwolfe.github.io/Buttons kitecss http://hiloki.github.io/kitecss pintuer http://www.pintuer.com amazeui http://amazeui.org worldhello http://www.worldhello.net/gotgithub/index.html linuxtoy http://igit.linuxtoy.org/contents.html gitmagic http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn rogerdudler http://rogerdudler.github.io/git-guide/index.zh.html gitref http://gitref.justjavac.com book http://git-scm.com/book/zh gogojimmy http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic 其它API 其它API 地址 HTTP API 设计指南 http://segmentfault.com/bookmark/1230000002521721 javascript流行库汇总 javascriptoo 验证api http://niceue.com/validator/demo/index.php underscore 中文手册 http://www.css88.com/doc/underscore underscore源码分析 http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031 underscore源码分析-亚里士朱德的博客 http://yalishizhude.github.io/tags/underscore underscrejs en api http://underscorejs.org lodash - underscore的代替品 https://lodash.com ext4api http://extjs-doc-cn.github.io/ext4api qwrap手册 http://dev.qwrap.com/resource/js/_docs/youa/#/qw/base/loadJs.htm 缓动函数 http://easings.net/zh-cn svg 中文参考 http://www.w3school.com.cn/svg/svg_reference.asp svg mdn参考 https://developer.mozilla.org/en-US/docs/Web/SVG svg 导出 canvas https://github.com/gabelerner/canvg svg 导出 png https://github.com/exupero/saveSvgAsPng ai-to-svg http://www.zamzar.com/convert/ai-to-svg localStorage 库 https://github.com/machao/localStorage 图表类 图表类 地址 Highcharts 中文API http://www.hcharts.cn/api/index.php Highcharts 英文API http://api.highcharts.com/highcharts ECharts 百度的图表软件 http://echarts.baidu.com/ 高德地图 http://lbs.amap.com/api 开源的矢量图脚本框架 http://paperjs.org svg 地图 http://jvectormap.com 正则 正则 地址 JS正则表达式元字符 http://segmentfault.com/a/1190000002471140 正则表达式30分钟入门教程 http://deerchao.net/tutorials/regex/regex.htm MDN-正则表达式 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions ruanyifeng - RegExp对象 http://javascript.ruanyifeng.com/stdlib/regexp.html 小胡子哥 - 进阶正则表达式 http://div.io/topic/764?page=1 is.js https://github.com/Cedriking/is.js/blob/master/is.js 正则在线测试 http://regexper.com 前端规范 前端规范 地址 通过分析github代码库总结出来的工程师代码书写习惯 http://alloyteam.github.io/CodeGuide HTML&amp;CSS编码规范 by @mdo http://codeguide.bootcss.com 团队合作的css命名规范-腾讯AlloyTeam前端团队 http://www.alloyteam.com/2011/10/css-on-team-naming/ 前端编码规范之js - by yuwenhui http://yuwenhui.github.io 前端编码规范之js - by 李靖 http://www.cnblogs.com/hustskyking/p/javascript-spec.html 前端开发规范手册 http://zhibimo.com/read/Ashu/front-end-style-guide Airbnb JavaScript 编码规范（简体中文版） https://github.com/yuche/javascript#table-of-contents AMD与CMD规范的区别 http://www.zhihu.com/question/20351507 AMD与CMD规范的区别 http://www.cnblogs.com/tugenhua0707/p/3507957.html KISSY 源码规范 http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html bt编码规范 http://codeguide.bootcss.com 规范加强版 https://github.com/Suxiaogang/Code_Guide 前端代码规范 及 最佳实践 http://blog.jobbole.com/79075 百度前端规范 http://coderlmn.github.io/code-standards 百度前端规范 http://isobar-idev.github.io/code-standards 百度前端规范 http://zhuanlan.zhihu.com/fuyun/19884834 ECMAScript6 编码规范–广发证券前端团队 https://github.com/gf-rd/es6-coding-style JavaScript 风格指南/编码规范（Airbnb公司版） http://blog.jobbole.com/79484 网易前端开发规范 http://nec.netease.com/standard css模块 http://www.75team.com/archives/1049 前端规范资源列表 https://github.com/ecomfe/spec PHP PHP 地址 最流行的PHP 代码规范 http://segmentfault.com/a/1190000000443795 最流行的PHP 代码规范 https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md 各大公司开源项目 各大公司开源项目 地址 Facebook Projects https://code.facebook.com/projects/web 百度web前端研发部 http://fex.baidu.com 百度EFE http://efe.baidu.com 百度github https://github.com/fex-team alloyteam http://www.alloyteam.com alloyteam-github http://alloyteam.github.io alloyteam-AlloyGameEngine https://github.com/AlloyTeam/AlloyGameEngine AlloyDesigner http://alloyteam.github.io/AlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具 H5交互页编辑器AEditor介绍 http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao H5动画交互页开发的工具介绍 AEditor http://aeditor.alloyteam.com H5动画交互页开发的工具 值得订阅的weekly https://github.com/fenbility/weekly-feed 奇舞团开源项目 http://75team.github.io Qunar UED http://ued.qunar.com Scrat http://scrat.io 常用 常用 地址 ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性 http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome 模拟键盘 http://mottie.github.io/Keyboard 拼音 https://github.com/hotoo/pinyin 中国个人身份证号验证 https://github.com/mc-zone/IDValidator 算法 算法 地址 数据结构与算法 JavaScript 描述. 章节练习 https://github.com/Ralph-Wang/algorithm.in.js 常见排序算法（JS版） https://github.com/twobin/twobinSort 经典排序 https://github.com/luofei2011/jsAgm/blob/master/js/sort.js 常见排序算法-js版本 https://github.com/hechangmin/jssort JavaScript 算法与数据结构 精华集 https://github.com/lightningtgc/JavaScript-Algorithms 面试常考算法题精讲 http://www.nowcoder.com/live/courses 移动端 移动端 地址 fastclick https://github.com/ftlabs/fastclick no-click-delay https://github.com/mmastrac/jquery-noclickdelay 【敏捷开发】Android团队开发规范 http://www.cnblogs.com/lcw/p/3619181.html Android 开发规范与应用 http://www.jianshu.com/p/4390f4fe19b3 ionic https://github.com/ychow/ionic-guide JSON JSON 地址 模拟生成JSON数据 http://beta.json-generator.com 焦点图 焦点图 地址 myfocus https://github.com/koen301/myfocus myfocus-官方演示站 http://www.chhua.com/myfocus SuperSlidev2.1 – 大话主席 http://www.superslide2.com soChange http://www.bujichong.com/sojs/soChange/index.html Ext, EasyUI, J-UI 及其它各种UI方案 Ext, EasyUI, J-UI 及其它各种UI方案 地址 雅虎UI - CSS UI http://developer.yahoo.com/yui/grids extjs https://www.sencha.com/products/extjs ext4英文api http://docs.sencha.com/extjs/4.0.7 ext4中文api http://extjs-doc-cn.github.io/ext4api jquery easyui 未压缩源代码 http://jquery-easyui.googlecode.com/svn/trunk/src J-UI http://jui.org MUI-最接近原生APP体验的高性能前端框架 http://dcloudio.github.io/mui Amaze UI(中国首个开源 HTML5 跨屏前端框架) http://amazeui.org 淘宝 HTML5 前端框架 http://m.sui.taobao.org KISSY - 阿里前端JavaScript库 http://docs.kissyui.com 网易Nej - Nice Easy Javascript http://nej.netease.com Kendo UI MVVM Demo http://demos.telerik.com/kendo-ui/mvvm/index 页面 社会化 分享功能 页面 社会化 分享功能 地址 百度分享 http://share.baidu.com pc端 JiaThis http://jiathis.com pc端 社会化分享组件 http://developer.baidu.com/soc/share 移动端 ShareSDK 轻松实现社会化功能 http://www.mob.com/#/index 移动端 友盟分享 http://dev.umeng.com/social/android/quick-integration 移动端 富文本编辑器 富文本编辑器 地址 功能齐全 tinymce https://www.tinymce.com 百度 ueditor http://ueditor.baidu.com/website 经典的ckeditor http://ckeditor.com 经典的kindeditor http://kindeditor.net wysiwyg http://www.bootcss.com/p/bootstrap-wysiwyg 一个有情怀的编辑器。Bach’s Editor http://integ.github.io/BachEditor tower用的编辑器 https://github.com/mycolorway/simditor summernote 编辑器 https://github.com/summernote/summernote html5编辑器 http://neilj.github.io/Squire Quilljs编辑器 http://quilljs.com wangEditor https://github.com/wangfupeng1988/wangEditor 前端概述 前端概述 地址 前端工具大全 http://www.awesomes.cn 什么是前端工程化 https://github.com/fouber/blog/issues/10?from=timeline&amp;isappinstalled=0# [译] 前端攻略-从路人甲到英雄无敌 https://segmentfault.com/a/1190000005174755 Gulp Gulp 地址 Gulp官网 http://gulpjs.com Gulp中文网 http://www.gulpjs.com.cn gulp资料收集 https://github.com/Platform-CUF/use-gulp Gulp：任务自动管理工具 - ruanyifeng http://javascript.ruanyifeng.com/tool/gulp.html Gulp插件 http://gulpjs.com/plugins Gulp探究折腾之路(I) http://www.jeffjade.com/2015/11/25/2015-11-25-toss-gulp/ Gulp折腾之路(II) http://www.jeffjade.com/2016/01/19/2016-01-19-toss-gulp/ Gulp不完全入门教程 http://www.ido321.com/1622.html 为什么使用gulp? https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33 Gulp安装及配合组件构建前端开发一体化 http://www.dbpoo.com/getting-started-with-gulp Gulp 入门指南 https://github.com/nimojs/gulp-book Gulp 入门指南 - nimojs https://github.com/nimojs/blog/issues/19 Gulp in Action http://www.imooc.com/video/5692 Gulp开发教程（翻译） http://www.w3ctech.com/topic/134 前端构建工具gulpjs的使用介绍及技巧 http://www.cnblogs.com/2050/p/4198792.html Grunt Grunt 地址 gruntjs http://gruntjs.com Grunt中文网 http://www.gruntjs.net Fis Fis 地址 fis 官网 http://fex-team.github.io/fis-site/index.html fis http://fis.baidu.com pc图轮 pc图轮 地址 Vue 的图片轮播组件:vue-slider https://github.com/qusiba/vue-slider 左右按钮多图切换 http://bxslider.com/examples/carousel-demystified fullpage全屏轮播 https://github.com/alvarotrigo/fullPage.js 移动端图轮 移动端图轮 地址 滑屏效果 http://www.idangero.us/swiper 全屏fullpage https://github.com/peunzhang/fullpage 单个图片切换 https://github.com/qiqiboy/touchslider 单个全屏切换 https://github.com/peunzhang/slip.js 百度的切换库 http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group 单个全屏切换 https://github.com/peunzhang/iSlider 滑屏效果 https://github.com/saw/touch-interfaces 旋转拖动设置 http://baijs.com/tinycircleslider 类似于swipe切换 http://touchslider.com 支持多种形式的触摸滑动 http://www.swiper.com.cn/demo/index.html 滑屏效果 https://github.com/joker-ye/main/blob/master/wap/index.html 大话主席pc移动图片轮换 http://www.superslide2.com 滑屏效果 https://github.com/hahnzhu/parallax.js 基于zepto的fullpage https://github.com/yanhaijing/zepto.fullpage [WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应 http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html 判断微信客户端的那些坑 http://loo2k.com/blog/detecting-wechat-client 可以通过javascript直接调用原生分享的工具 https://github.com/JefferyWang/nativeShare.js JiaThis 分享到微信代码 http://www.jiathis.com/help/html/weixin-share-code 聊聊移动端跨平台开发的各种技术 http://fex.baidu.com/blog/2015/05/cross-mobile 前端自动化测试 http://www.zhihu.com/question/29922082 多种轮换图片 http://ajccom.github.io/niceslider 滑动侧边栏 https://mango.github.io/slideout 文件上传 文件上传 地址 百度上传组件 http://fex.baidu.com/webuploader 上传 https://blueimp.github.io/jQuery-File-Upload flash 头像上传 http://www.hdfu.net 图片上传预览 http://www.dropzonejs.com 图片裁剪 http://elemefe.github.io/image-cropper 图片裁剪-shearphoto http://www.shearphoto.com jQuery图片处理 http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&amp;os=0&amp;sort=view&amp;p=2 模拟select 模拟select 地址 糖饼 select http://aui.github.io/popupjs/doc/selectbox.html flexselect https://github.com/rmm5t/jquery-flexselect 双select http://loudev.com select2 http://select2.github.io 取色插件 取色插件 地址 类似 Photoshop 的界面取色插件 http://www.jq22.com/plugin/367 jquery color https://github.com/jquery/jquery-color 取色插件集合 http://www.oschina.net/project/tag/287/color-picker farbtastic 圆环＋正方形 https://github.com/mattfarina/farbtastic 城市联动 城市联动 地址 jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果 http://www.ijquery.cn/?p=360 剪贴板 剪贴板 地址 剪贴板 https://github.com/zeroclipboard/zeroclipboard clipboard 最新的剪切方案 http://zenorocha.github.io/clipboard.js 不是Flash的剪贴板 https://github.com/zenorocha/clipboard.js 简繁转换 简繁转换 地址 简繁转换 https://github.com/BYVoid/OpenCC 表格 Grid 表格 Grid 地址 facebook表格 http://facebook.github.io/fixed-data-table 类似于Excel编辑表格-handsontable http://handsontable.com bootstrap-table插件 http://bootstrap-table.wenzhixin.net.cn datatables https://www.datatables.net 在线演示 在线演示 地址 js 在线编辑 - runjs http://runjs.cn js 在线编辑 - jsbin http://jsbin.com js 在线编辑 - codepen http://codepen.io js 在线编辑 - jsfiddle http://jsfiddle.net java 在线编辑 - runjs http://ideone.com js 在线编辑 - hcharts http://code.hcharts.cn js 在线编辑 - jsdm http://jsdm.com sql 在线编辑 - sqlfiddle http://sqlfiddle.com mozilla 在线编辑器 https://thimble.mozilla.org 常规优化 常规优化 地址 Javascript高性能动画与页面渲染 http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering 移动H5前端性能优化指南 http://isux.tencent.com/h5-performance.html 5173首页前端性能优化实践 http://ued.5173.com/?p=1731 给网页设计师和前端开发者看的前端性能优化 http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers 复杂应用的 CSS 性能分析和优化建议 http://www.orzpoint.com/profiling-css-and-optimization-notes 张鑫旭——前端性能 张鑫旭——前端性能 前端性能监控总结 http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html 网站性能优化之CSS无图片技术 网站性能优化之CSS无图片技术 web前端性能优化进阶路 web前端性能优化进阶路 前端技术：网站性能优化之CSS无图片技术 http://my.eoe.cn/tuwandou/archive/4544.html 浏览器的加载与页面性能优化 http://www.baiduux.com/blog/2011/02/15/browser-loading 页面加载中的图片性能优化 http://www.w3ctech.com/p/1503 Hey——前端性能 Hey——前端性能 html优化 html优化 99css——性能 99css——性能 YSLOW中文介绍 http://www.cnblogs.com/yslow 转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化 http://www.360ito.com/article/40.html Yahoo!团队实践分享：网站性能 http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml 网站性能优化指南：什么使我们的网站变慢？ http://blog.jiasule.com/i/153 网站性能优化实践，减少加载时间，提高用户体验 http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html 浅谈网站性能优化 前端篇 http://www.umtry.com/archives/747.html 前端重构实践之如何对网站性能优化？ http://www.adinnet.cn/blog/designview/2012-7-12/678.html 前端性能优化：使用媒体查询加载指定大小的背景图片 http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9 网站性能系列博文 http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html 加载，不只是少一点点 http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml 前端性能的测试与优化 http://mzhou.me/article/95310 分享网页加载速度优化的一些技巧？ http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading web前端优化(基于Yslow http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html 网站性能优化工具大全 https://www.qianduan.net/website-performance-optimization-tool.html 【高性能前端1】高性能HTML http://www.alloyteam.com/2012/10/high-performance-html 【高性能前端2】高性能CSS http://www.alloyteam.com/2012/10/high-performance-css 由12306谈谈网站前端性能和后端性能优化 http://coolshell.cn/articles/6470.html AlloyTeam——前端优化 AlloyTeam——前端优化 毫秒必争，前端网页性能最佳实践 http://www.cnblogs.com/developersupport/p/3248695.html 网站性能工具Yslow的使用方法 http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html 前端工程与性能优化（上）：静态资源版本更新与缓存 http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1 前端工程与性能优化（下）：静态资源管理与模板框架 http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2 HTTPS连接的前几毫秒发生了什么 http://blog.jobbole.com/48369 Yslow http://uicss.cn/yslow/#more-12319 Essential Web Performance Metrics — A Primer, Part 1 http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1 Essential Web Performance Metrics — Part 2 http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2 YUISlide,针对移动设备的动画性能优化 http://jayli.github.io/blog/data/2011/12/23/yuislide.html Improving Site Performance http://joelglovier.com/improving-site-performance 让网站提速的最佳前端实践 http://segmentfault.com/a/1190000000367899 Why Website Speed is Important http://sixrevisions.com/web-development/why-website-speed-is-important Need for Speed – How to Improve your Website Performance https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance 阿里无线前端性能优化指南 (Pt.1 加载期优化 https://github.com/amfe/article/issues/1 优化工具 优化工具 地址 JavaScript 性能分析新工具 OneProfile http://www.html-js.com/article/3083 JavaScript 堆内存分析新工具 OneHeap http://www.html-js.com/article/3091 在线工具 在线工具 地址 google在线工具 https://developers.google.com/speed/pagespeed/insights 阿里-免费测试服务 http://itest.aliyun.com 阿里-F2etest多浏览器兼容性测试解决方案 https://github.com/alibaba/f2etest js性能测试 http://jsperf.com 前端架构 前端架构 地址 技术架构 http://www.zhihu.com/topic/19612641 前端架构 http://saito.im/note/The-Architecture-of-F2E 如何成为前端架构师 http://www.zhihu.com/question/24092572 关于前端架构-张克军 http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html 百度腾讯offer比较（腾讯游戏VS百度基础架构） http://www.zhihu.com/question/25583350 推荐作品 推荐作品 地址 winter代码片段需要翻墙 https://gist.github.com/wintercn fgm http://www.fgm.cc/learn 岑安作品集 https://github.com/hongru/hongru.github.com 当耐特demo集合 http://kmdjs.github.io 米空格 js作品 http://www.laoshu133.com/Lab myFocus http://koen301.github.io SeaJS组件库 http://panxuepeng.github.io/seajslib 颜海镜作品 http://yanhaijing.com/myProject 脚儿网作品 http://jo2.org/category/myworks javascript个人作品 http://www.cnitblog.com/yemoo/category/3107.html 妙味的雷东升游戏作品 http://bbs.miaov.com/forum.php?mod=viewthread&amp;tid=7790 javascript作品集 http://bbs.csdn.net/topics/380227212 云五笔，灰度产生生成工具 https://github.com/TooBug/works 项目主页 http://koen301.github.io 个性的作品主页 http://zaole.net ucren js demos 集 http://ucren.com/blog/demos 智能社 http://www.zhinengshe.com/works_list.html 实例陈列架 http://demos.shizuwu.cn zoye demo http://zoye.sinaapp.com/demo 王员外 http://lab.yuanwai.wang 平凡 http://pingfan1990.sinaapp.com jyg 游戏案例 http://www.lovewebgames.com 很多jquery插件 http://www.helloweba.com/list.html 不羁虫 - soJs 作品系列 http://www.bujichong.com/sojs/api/index.html frozenui http://frozenui.github.io/case.html 黑白棋 http://js-game.github.io/othello fromone http://yansm.github.io/fromone/index.html pazguille http://pazguille.me Html5 VideoPlayer https://github.com/zmmbreeze/DeadSimpleVideoPlayer Proton 烟花 http://a-jie.github.io/Proton/#example 简历模板 简历模板 地址 简历 http://hcy2367.github.io/resume 张伦 http://ncuey.sinaapp.com/CrispElite/ 简历 https://github.com/hacke2/ResumeSample 马斯特 http://pinkyjie.com/resume 张秋怡 https://joyeecheung.github.io/resume/ 翁天信 http://blog.dandyweng.com/2013/07/how-my-website-was-created 动画方式的简历 http://www.webhek.com/misc/interactive-resume 组件丰富简历 http://www.linqing07.com/resume.html haorooms博客 http://www.haorooms.com/about 面试题 面试题 地址 那几个月在找工作（百度，网易游戏） http://www.nowcoder.com/discuss/3196 2014最新面试题 http://www.html-js.com/article/1743 2016校招内推 – 阿里巴巴前端 – 三面面试经历 http://www.cnblogs.com/imwtr/p/4685546.html 年后跳槽那点事：乐视+金山+360面试之行 http://www.cnblogs.com/lvdabao/p/3660707.html Interviewing a front-end developer http://blog.sourcing.io/interview-questions 拉勾网js面试题 http://www.cnblogs.com/52cik/p/js-question-lg.html 前端面试 http://www.cnblogs.com/allenxing/p/3724382.html Web开发笔试面试题 大全 http://mianshiti.diandian.com 前端开发面试题 http://segmentfault.com/a/1190000000465431 2014最新前端面试题 https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions 百度面试 https://github.com/fex-team/interview-questions 前端工作面试问题 https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese 前端开发面试题 http://segmentfault.com/a/1190000000465431 5个经典的前端面试问题 5个经典的前端面试问题 最全前端面试问题及答案总结 http://segmentfault.com/a/1190000002562454 如何面试一名前端开发工程师？ http://www.html-js.com/article/Large-search-front-team-column%202961 史上最全 前端开发面试问题及答案整理 https://github.com/hawx1993/Front-end-Interview-questions 前端实习生面试总结 http://www.cnblogs.com/xiaoruo/p/4665163.html 史上最全 前端开发面试问题及答案整理 https://github.com/hawx1993/Front-end-Interview-questions BAT及各大互联网公司2014前端笔试面试题：JavaScript篇 http://blog.jobbole.com/78738 前端开发面试题大收集 https://github.com/paddingme/Front-end-Web-Development-Interview-Question 收集的前端面试题和答案 https://github.com/qiu-deqing/FE-interview 如何面试前端工程师 http://www.zhihu.com/question/19568008 前端开发面试题 https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md 牛客网-笔试面经 http://www.nowcoder.com/discuss?type=2 iconfont iconfont 地址 中文字体 http://www.zhihu.com/question/21253343 淘宝字库 http://iconfont.cn 字体 http://mux.alimama.com/fonts 制作教程 http://iconfont.cn/help/platform.html zhangxinxu-icommon http://www.zhangxinxu.com/wordpress/?s=icomoon icommon https://icomoon.io/app 用字体在网页中画ICON图标(推荐教程 http://imooc.com/learn/243 字体压缩工具 http://font-spider.org Fiddler Fiddler 地址 Fiddler调式使用知多少(一深入研究 http://www.cnblogs.com/tugenhua0707/p/4623317.html 微信fiddle http://www.cnblogs.com/strick/p/4570006.html 微信fiddle http://gaoboy.com/article/26.html Chrome Chrome 地址 Google Chrome 官方 https://developer.chrome.com/devtools Chrome - 基础 http://www.cnblogs.com/constantince/p/4565261.html Chrome - 进阶 http://www.cnblogs.com/constantince/p/4579121.html Chrome - 性能 http://www.cnblogs.com/constantince/p/4585983.html Chrome - 性能进阶 http://www.cnblogs.com/constantince/p/4607497.html Chrome - 移动 http://www.cnblogs.com/constantince/p/4624241.html Chrome - 使用技巧 http://www.cnblogs.com/liyunhua/p/4544738.html Chrome - Console控制台不完全指南 http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html Chrome - Workspace使浏览器变成IDE http://c7sky.com/chrome-devtools-workspace.html network面板 http://www.html-js.com/article/Nothing-blind%202975 chrome开发工具快捷键 http://anti-code.com/devtools-cheatsheet chrome调试工具常用功能整理 http://www.html-js.com/article/2327 Chrome 开发工具 Workspace 使用 http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace Chrome神器Vimium快捷键学习记录 http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html sass调试-w3cplus http://www.w3cplus.com/sassguide/debug.html 如何更专业的使用Chrome开发者工具-w3cplus http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html chrome调试canvas http://sentsin.com/web/253.html chrome profiles1 https://developer.chrome.com/devtools/index chrome profiles3 http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles chrome移动版调试 https://developer.chrome.com/devtools/docs/mobile-emulation chrome调试 http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool chrome的调试 http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html chrome console 命令详解 https://developer.chrome.com/devtools/docs/commandline-api 查看事件绑定1 http://www.cnblogs.com/leonkao/p/3809655.html 查看事件绑定2 http://www.cnblogs.com/xiaoyao2011/p/3447421.html 神器——Chrome开发者工具(一 http://segmentfault.com/a/1190000000683599 奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍 https://xinranliu.me/2015-05-22-qiqu-performance chrome 开发者工具的 15 个小技巧 http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html Chrome开发者工具不完全指南 http://1ke.co/course/361 Chrome 开发者工具使用技巧 http://segmentfault.com/a/1190000003882567 Firebug Firebug 地址 firebug视频教程 http://www.imooc.com/learn/137 firefox 模拟器 https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE console.log 命令详解 http://www.cnblogs.com/ctriphire/p/4116207.html Firebug入门指南 http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html Firebug控制台详解 http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html 移动,微信调试 移动,微信调试 地址 浏览器端调试安卓 https://openstf.github.io 移动端前端开发调试 http://yujiangshui.com/multidevice-frontend-debug 使用 Chrome 远程调试 Android 设备 https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md mac移动端调试 http://plus.uc.cn/document/webapp/doc5.html mac移动端调试 http://www.mihtool.com 无线调试攻略 http://thx.github.io/mobile/debugging-in-mobile 无线调试攻略 http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile 屌爆了,完美调试 微信webview(x5 http://www.jianshu.com/p/ccf124f1f74b 微信调试的那些事 微信调试的那些事 远程console http://jsconsole.com 微信调试工具 http://blog.qqbrowser.cc 各种真机远程调试方法汇总 https://github.com/jieyou/remote_inspect_web_on_real_device iOS Simulator iOS Simulator 地址 Simulator iOS_Simulator_Guide-Introduction iOS Simulator的介绍和使用心得 http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary Image img 地址 loading img http://preloaders.net/en/circular 智图-图片优化平台 http://zhitu.isux.us 在线png优化 https://tinypng.com SM.MS(图床工具～简易好用) https://sm.ms/ yutuku：极简图床 http://yotuku.cn/ Qchan图床 http://tuchuang.org/ 浏览器同步 浏览器同步 地址 puer https://github.com/leeluolee/puer liveReload http://livereload.com f5 http://getf5.com File Watchers http://geek100.com/2608 在线PPT制作 在线PPT制作 地址 nodePPT nodePPT Cleaver快速制作网页PPT http://www.jeffjade.com/2015/10/15/2015-10-16-cleaver-make-ppt/ impress.js http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.html PPT https://github.com/ksky521/nodePPT reveal https://github.com/hakimel/reveal.js bespoke-fx https://github.com/ebow/bespoke-fx slippy https://github.com/Seldaek/slippy 前端导航网站 前端导航网站 地址 界面清爽的前端导航 http://uxbees.com/index.html 前端导航 http://whycss.com 前端网址导航 http://www.daqianduan.com/nav 前端名录 http://sentsin.com/daohang 前端导航 http://123.jser.us 前端开发资源 http://www.css88.com/nav 前端开发仓库 - 众多效果的收集地 http://code.ciaoca.com 前端资源导航 https://github.com/jnoodle/f2e-collect F2E 前端导航 http://f2e.im/static/pages/nav/index.html 常用CDN 常用CDN 地址 新浪CDN http://lib.sinaapp.com 百度静态资源公共库 http://cdn.code.baidu.com 360网站卫士常用前端公共库CDN服务 http://libs.useso.com Bootstrap中文网开源项目免费 CDN 服务 http://www.bootcdn.cn 开放静态文件 CDN - 七牛 http://staticfile.org CDN加速 - jq22 http://www.jq22.com/cdn jQuery CDN http://code.jquery.com 微软CDN http://www.asp.net/ajax/cdn Git Git 地址 git-scm http://git-scm.com 廖雪峰-Git教程 廖雪峰-Git教程 git-for-windows https://git-for-windows.github.io GitHub 添加 SSH keys http://daemon369.github.io/git/2015/03/10/add-ssh-keys-for-github gogithub http://www.worldhello.net/gotgithub/index.html git常规命令练习 http://pcottle.github.io/learnGitBranching git的资料整理 https://github.com/xirong/my-git 我所记录的git命令（非常实用） http://www.cnblogs.com/fanfan259/p/4810517.html 企业开发git工作流模式探索部分休整 https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md GitHub 漫游指南 https://github.com/phodal/github-roam GitHub秘籍 https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md 使用git和github进行协同开发流程 http://livoras.com/post/28 动画方式练习git http://onlywei.github.io/explain-git-with-d3 各种日期日历 各种日期日历 地址 经典my97 http://www.my97.net/dp/demo/index.htm 强大的独立日期选择器 http://www.cnblogs.com/gbin1/archive/2012/04/16/2452105.html fullcalendar http://fullcalendar.io fullcalendar日历控件知识点集合 http://blog.csdn.net/francislaw/article/details/7740630 中文api http://blog.sina.com.cn/s/blog_9475b1c101012c5f.html 农历日历 https://github.com/zzyss86/LunarCalendar 超酷的仿百度带节日日历老黄历控件 http://www.sucaisj.com/jiaoben/date/201509/16856.html 日期格式化 http://momentjs.com 大牛日历控件 https://github.com/Johnqing/QPAYCalendar 我群某管理作品 https://github.com/Iamlars/dateMarker input按位替换-官网 http://digitalbush.com/projects/masked-input-plugin input按位替换-github https://github.com/digitalBush/jquery.maskedinput/tree/1.2.2 bootstrap-daterangepicker https://github.com/dangrossman/bootstrap-daterangepicker 国外30个插件集合 http://www.vandelaydesign.com/30-best-free-jquery-plugins JavaScript datepicker http://dbushell.com/2012/10/09/pikaday-javascript-datepicker Datepair.js http://jonthornton.github.io/Datepair.js 一个风格多样的日历 https://github.com/glad/glDatePicker 弹出层式的全日历 http://amsul.ca/pickadate.js/date jquery双日历 http://www.daterangepicker.com 大气实用jQuery手机移动端日历日期选择插件 http://www.frankdemo.cn/index.php?c=content&amp;a=show&amp;id=115 jQuery Mobile 移动开发中的日期插件Mobiscroll https://mobiscroll.com Date library Date library 地址 Datejs https://github.com/datejs/Datejs sugarjs http://sugarjs.com/api/Date 其它 其它 地址 Mock.js 是一款模拟数据生成器 http://mockjs.com 特色的HTML框架可以创建精美的iOS应用 http://framework7.taobao.org 淘宝SUI http://m.sui.taobao.org avalonjs http://avalonjs.github.io Avalon新一代UI库： OniUI http://ued.qunar.com/oniui/index.html avalon.oniui-基于avalon的组件库 https://github.com/RubyLouvre/avalon.oniui 生成二维码(草料) http://cli.im 效果类 效果类 地址 弹出层 http://www.imooc.com/learn/58 焦点图轮播特效 http://www.imooc.com/learn/18 HTML5 有哪些让你惊艳的 demo？ http://www.zhihu.com/question/24398907 弹出层 弹出层 地址 artDialog 最新版 https://github.com/aui/artDialog artDialog 文档 http://aui.github.io/artDialog/doc/index.html google code 下载地址 https://code.google.com/p/artdialog/downloads/list 贤心弹出层 http://layer.layui.com 响应式用户交互组件库 https://github.com/bh-lay/UI sweetalert-有css3动画弹出层 http://t4t5.github.io/sweetalert 优秀JavaScript项目 优秀JavaScript项目 地址 Angular和Webpack种子文件 https://github.com/AngularClass/angular2-webpack-starter Fis3面向前端的工程构建系统 https://github.com/fex-team/fis3 Fis3 DEMO https://github.com/fex-team/fis3-demo 前端JQuery系列:源码剖析 https://github.com/JsAaron/jQuery avalon框架 https://github.com/RubyLouvre/avalon Microsoft ChakraCore 微软的Chakra引擎 https://github.com/Microsoft/ChakraCore Quintus HTML游戏引擎 https://github.com/cykod/Quintus 一个用node.js搭建的有趣博客 https://github.com/STRML/strml.net Web前端助手–FeHelper（Chrome扩展） https://github.com/zxlie/FeHelper 百度前端技术学院 https://github.com/baidu-ife/ife Cheerio（node.js中的jQuery） https://github.com/cheeriojs/cheerio nodejs的一个聊天软件 类似微信 https://github.com/BryanYang/freechat 使用html5和node.js构建的网易云音乐 https://github.com/stkevintan/Cube babel ES6转换为ES5 https://github.com/babel/babel 一个JS富文本编辑器 https://github.com/fex-team/ueditor 一个JS脑图可视化工具 https://github.com/fex-team/kityminder-core 一个JS写的Flappy Bird Game https://github.com/ellisonleao/clumsy-bird 一个JS写的GBA模拟器 https://github.com/taisel/IodineGBA SegmentFault写的Markdown解析器 https://github.com/SegmentFault/HyperDown.js 基于node.js的Ghost博客 https://github.com/TryGhost/Ghost 学习react的demos https://github.com/ruanyf/react-demos 转载请保留原链接：http://www.jeffjade.com/2016/03/30/104-front-end-tutorial/ 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/Resources/2017/02/24/前端资源汇集.html]]></content>
      <categories>
        <category>Resources</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>chm</tag>
        <tag>HTML5</tag>
        <tag>CSS</tag>
        <tag>vue</tag>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown简明语法]]></title>
    <url>%2FEditor%2F2017%2F02%2F22%2FMarkDown%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[『Cmd 技术渲染的沙箱页面，点击此处编写自己的文档』 Cmd Markdown 简明语法手册标签： Cmd-Markdown 1. 斜体和粗体使用 一个号 和 2个*号 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 示例：#一级标题 ##二级标题 以此类推 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$ $$\sum^{j-1}{k=0}{\widehat{\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 13. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： [ ] Cmd Markdown 开发 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [ ] 支持以 PDF 格式导出文稿 [x] 新增Todo列表功能 语法参考 [x] 改进 LaTex 功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 语法参考 [ ] 七月旅行准备 [ ] 准备邮轮上需要携带的物品 [ ] 浏览日本免税店的物品 [x] 购买蓝宝石公主号七月一日的船票 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/Editor/2017/02/22/MarkDown简明语法.html]]></content>
      <categories>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cmd Markdown 编辑阅读器]]></title>
    <url>%2FEditor%2F2017%2F02%2F20%2FCmd%20Markdown.html</url>
    <content type="text"><![CDATA[欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 欢迎转载，但转载请注明来自”勿忘初心”的博客，并保持转载后文章内容的完整性。 本文链接：http://lucylc.com/Editor/2017/02/20/Cmd Markdown.html]]></content>
      <categories>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
